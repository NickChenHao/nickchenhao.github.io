<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RN集成到原生应用</title>
    <url>/2019/07/22/RN%E9%9B%86%E6%88%90%E5%88%B0%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://reactnative.cn/docs/integration-with-existing-apps">集成到现有原生应用</a><br><a href="https://www.jianshu.com/p/ea8dc1e078f1">将RN集成到iOS原生项目中</a><br><a href="https://www.jianshu.com/p/bdaef44c6207">RN嵌入到现有iOS原生应用</a><br><a href="https://www.jianshu.com/p/1927785a3ba7">将RN工程嵌入到现有iOS原生应用</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>虽然看了ReactNative官网还有网上的这些资料，有说怎么集成，但多多少少感觉不太对，写出来也是有问题，所以在这里记录一下集成成功的步骤，减少踩坑！<br><span id="more"></span></p>
<h4 id="步骤-以0-48-4版本RN为例"><a href="#步骤-以0-48-4版本RN为例" class="headerlink" title="步骤 (以0.48.4版本RN为例)"></a>步骤 (以0.48.4版本RN为例)</h4><h5 id="新建相关文件"><a href="#新建相关文件" class="headerlink" title="新建相关文件"></a>新建相关文件</h5><ul>
<li>在原生项目.xcodeproj同级 <code>mkdir RNUntils</code> 新建RNUntils存放RN相关 </li>
<li>在RNUntils目录下 <code>touch package.json</code> 新建文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;RNUntils&quot;, </span><br><span class="line">    &quot;version&quot;: &quot;0.0.1&quot;, </span><br><span class="line">    &quot;private&quot;: true, </span><br><span class="line">    &quot;scripts&quot;: &#123; </span><br><span class="line">        &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot; </span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123; </span><br><span class="line">        &quot;react&quot;: &quot;16.0.0-alpha.12&quot;, </span><br><span class="line">        &quot;react-native&quot;: &quot;0.48.4&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行npm install 会自动生成node_modules</li>
<li>在RNUntils目录下 <code>touch index.js</code> 新建文件</li>
</ul>
<p><font color="#dd0000"><strong>注</strong>：创建一个空的index.js文件。（注意在 0.49 版本之前是 index.ios.js 文件）</font><br /> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;</span><br><span class="line">    AppRegistry,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View</span><br><span class="line">&#125; from &#x27;react-native&#x27;;</span><br><span class="line">export default class DemoApp extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">                &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">                Welcome to React Native!</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                To get started, edit index.ios.js</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                Press Cmd+R to reload,&#123;&#x27;\n&#x27;&#125;</span><br><span class="line">                Cmd+D or shake for dev menu</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">container: &#123;</span><br><span class="line">flex: 1,</span><br><span class="line">justifyContent: &#x27;center&#x27;,</span><br><span class="line">alignItems: &#x27;center&#x27;,</span><br><span class="line">backgroundColor: &#x27;#F5FCFF&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">welcome: &#123;</span><br><span class="line">fontSize: 20,</span><br><span class="line">textAlign: &#x27;center&#x27;,</span><br><span class="line">margin: 10,</span><br><span class="line">&#125;,</span><br><span class="line">instructions: &#123;</span><br><span class="line">textAlign: &#x27;center&#x27;,</span><br><span class="line">color: &#x27;#333333&#x27;,</span><br><span class="line">marginBottom: 5,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">AppRegistry.registerComponent(&#x27;TestReactNative&#x27;, () =&gt; DemoApp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注：此处最后一行代码中的RNHighScores是自定义的rn组件的名字，iOS原生代码调用时需要用到</span><br></pre></td></tr></table></figure>
<ul>
<li>在RNUntils文件下 终端运行 <code>react-native bundle --platform ios --dev false --entry-file index.ios.js --bundle-output main.jsbundle</code> 生成的 main.jsbundle 导入到原生项目中 再运行 <code>npm start</code><ul>
<li><font color="#dd0000">其中 index.ios.js” 根据根目录上的index.js  （0.49版本之前是index.ios.js）</font><br /> </li>
<li>ios/main.jsbundle  是根据在xcodeproj同级目录下的路径</li>
</ul>
</li>
<li>编辑podfile文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    # &#x27;node_modules&#x27;目录一般位于根目录中</span><br><span class="line">    # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`</span><br><span class="line">    pod &#x27;React&#x27;, :path =&gt; ‘RNUntils/node_modules/react-native&#x27;, :subspecs =&gt; [</span><br><span class="line">        &#x27;Core&#x27;,</span><br><span class="line">        &#x27;CxxBridge&#x27;, # 如果RN版本 &gt;= 0.47则加入此行</span><br><span class="line">        &#x27;DevSupport&#x27;, # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class="line">        &#x27;RCTText&#x27;,</span><br><span class="line">        &#x27;RCTNetwork&#x27;,</span><br><span class="line">        &#x27;RCTWebSocket&#x27;, # 调试功能需要此模块</span><br><span class="line">        &#x27;RCTAnimation&#x27;, # FlatList和原生动画功能需要此模块</span><br><span class="line">    # 在这里继续添加你所需要的其他RN模块</span><br><span class="line">    ]</span><br><span class="line">    # 如果RN版本 &gt;= 0.42.0，则加入下面这行</span><br><span class="line">    pod &#x27;Yoga&#x27;, :path =&gt; ‘RNUntils/node_modules/react-native/ReactCommon/yoga’</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 <code>pod install</code><br><font color="#dd0000"><strong>注</strong>：(若 0.44.3之后版本 boost pod不下来 <a href="https://juejin.im/post/5c88711df265da2db30591de">解决方案</a>) 貌似换了 更不行 可能和网有关 可以试试！ （更换后 需要先删除pod缓存  ~/Library/Caches/Cocoapods  再pod repo update 再 pod install才可以）<br></font><br /> <h5 id="原生调用"><a href="#原生调用" class="headerlink" title="原生调用"></a>原生调用</h5></li>
<li>需要先导入 <code>&lt;React/RCTRootView.h&gt;、&lt;React/RCTBundleURLProvider.h&gt;</code></li>
<li><p>调用代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	    NSURL *jsCodeLocation = </span><br><span class="line">[[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; </span><br><span class="line">                                               fallbackResource:nil];</span><br><span class="line">    RCTRootView *rootView =</span><br><span class="line">    [[RCTRootView alloc] initWithBundleURL : jsCodeLocation</span><br><span class="line">                         moduleName        : @&quot;TestReactNative&quot; </span><br><span class="line">                         initialProperties :nil </span><br><span class="line">                          launchOptions    : nil]; </span><br><span class="line">    UIViewController *vc = [[UIViewController alloc] init];</span><br><span class="line">    vc.view = rootView;</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#dd0000">其中 @”index” 根据根目录上的index.js  （0.49版本之前是index.ios.js）</font><br /> </li>
<li><code>@&quot;TestReactNative&quot;</code> 是js文件中最后写的名称</li>
</ul>
</li>
<li><p>需要修改info.plist文件<br><img src="/images/RN集成原生项目修改info文件.png" alt=""></p>
</li>
</ul>
<hr>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><font color="#dd0000"><em>以上是 在原生项目.xcodeproj同级 新建RNUntils文件存放RN相关 的操作流程<br>以下是 新建RNUntils文件存放RN相关、新建子文件ios 存放原生项目 的操作流程</em><br></font><br /><em>区别在步骤 1、5、6上</em><br>1、新建文件夹专门放RN相关文件如RNUntils  新建子文件夹ios 将原生项目.xcodeproj同级所有文件复制到ios目录下<br>5、终端运行 修改 <code>main.jsbundle</code> 为 <code>ios/main.jsbundle</code><br>6、在 podfile 文件 修改 <code>:path =&gt; &#39;RNUntils/node_modules/react-native</code> 为 <code>:path =&gt; &#39;../node_modules/react-native</code> </p>
]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage初探</title>
    <url>/2019/06/12/SDWebImage%E5%88%9D%E7%BA%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>记录一下SDWebImage第三方源码的研究</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/images/SDWebImage流程图.png" alt="流程图"></p>
<h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存</span><br><span class="line">如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来</span><br><span class="line">如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片</span><br><span class="line">下载后的图片会加入缓存中，并写入磁盘中</span><br><span class="line">整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来</span><br></pre></td></tr></table></figure>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - 检查图片缓存</span><br><span class="line">    //从内存缓存中取出</span><br><span class="line">    if(有图片)</span><br><span class="line">    &#123;</span><br><span class="line">        //直接设置</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">#pragma mark - 检查磁盘缓存</span><br><span class="line">    //获取文件路径</span><br><span class="line"></span><br><span class="line">    //得到图片的名称 获取节点</span><br><span class="line"></span><br><span class="line">    //拼接文件的全路径</span><br><span class="line"></span><br><span class="line">    //从磁盘缓存中取出</span><br><span class="line"></span><br><span class="line">    if(data)</span><br><span class="line">    &#123;   //将二进制数去转成图片</span><br><span class="line"></span><br><span class="line">        //设置图片</span><br><span class="line"></span><br><span class="line">        //把图片存到内存缓存中</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">#pragma mark - 检查操作缓存</span><br><span class="line">        //清空图片或者是设置占位图片</span><br><span class="line"></span><br><span class="line">        //检查操作缓存</span><br><span class="line"></span><br><span class="line">        if (操作缓存) &#123;</span><br><span class="line">            //如果存在,那么什么都不做</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //操作步骤</span><br><span class="line">            &#123;</span><br><span class="line">                //下载图片三步骤</span><br><span class="line">                if (图片为空) &#123;</span><br><span class="line">                    //移除操作缓存中的操作</span><br><span class="line"></span><br><span class="line">                    //直接返回</span><br><span class="line">                    return ;</span><br><span class="line">                &#125;</span><br><span class="line">                //把图片存到内存缓存中</span><br><span class="line"></span><br><span class="line">                //把图片保存到磁盘缓存</span><br><span class="line"></span><br><span class="line">                //回到主线程设置图片</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //添加操作到缓存中</span><br><span class="line"></span><br><span class="line">            //将操作加入队列</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#pragma mark - 移除缓存策略</span><br><span class="line">    //移除内存缓存</span><br><span class="line"></span><br><span class="line">    //取消队列中的操作</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下载图片的核心方法</span><br><span class="line">/*</span><br><span class="line"> * url          图片的二进制数据</span><br><span class="line"> * placeholder  UIImageView的占位图片</span><br><span class="line"> * options      图片下载选项（策略）</span><br><span class="line"> * progressBlock    进度回调</span><br><span class="line"> * completedBlock   完成回调</span><br><span class="line"> */</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line"></span><br><span class="line">    // 取消当前图像下载</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line"></span><br><span class="line">    // 利用运行时retain url</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    //判断，如果传入的下载策略不是延迟显示占位图片，那么在主线程中设置占位图片</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            // 设置占位图像</span><br><span class="line">            self.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果url不为空</span><br><span class="line">    if (url) &#123;</span><br><span class="line"></span><br><span class="line">        // check if activityView is enabled or not</span><br><span class="line">        //检查activityView是否可用</span><br><span class="line">        if ([self showActivityIndicatorView]) &#123;</span><br><span class="line">            [self addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        // 实例化 SDWebImageOperation 操作</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            //移除UIActivityIndicatorView</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            if (!wself) return;</span><br><span class="line"></span><br><span class="line">            //下面block中的操作在主线程中处理</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!wself) return;</span><br><span class="line">                //如果图片下载完成，且传入的下载选项为手动设置图片则直接执行completedBlock回调，并返回</span><br><span class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (image) &#123;   //否则，如果图片存在，则设置图片到UIImageView上面，并刷新重绘视图</span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果没有得到图像</span><br><span class="line">                    //如果传入的下载选项为延迟显示占位图片，则设置占位图片到UIImageView上面，并刷新重绘视图</span><br><span class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果url为空，则在主线中处理下面的操作</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            //移除UIActivityIndicatorView</span><br><span class="line">            [self removeActivityIndicator];</span><br><span class="line"></span><br><span class="line">            //处理错误信息，并执行任务结束回调，把错误信息作为参数传递出去</span><br><span class="line">            NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下载操作队列"><a href="#下载操作队列" class="headerlink" title="下载操作队列"></a>下载操作队列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片 ，否则返回缓存的图像</span><br><span class="line"> *</span><br><span class="line"> * @param url 图片的URL地址</span><br><span class="line"> * @param options 指定此次请求策略的选项</span><br><span class="line"> * @param progressBlock 图片下载进度的回调</span><br><span class="line"> * @param completedBlock 操作完成后的回调</span><br><span class="line"> *      此参数是必须的，此block没有返回值</span><br><span class="line"> *      Image：请求的 UIImage，如果出现错误，image参数是nil</span><br><span class="line"> *      error：如果出现错误，则error有值</span><br><span class="line"> *      cacheType：`SDImageCacheType` 枚举，标示该图像的加载方式</span><br><span class="line"> *          SDImageCacheTypeNone：从网络下载</span><br><span class="line"> *          SDImageCacheTypeDisk：从本地缓存加载</span><br><span class="line"> *          SDImageCacheTypeMemory：从内存缓存加载</span><br><span class="line"> *          finished：如果图像下载完成则为YES，如果使用 SDWebImageProgressiveDownload 选项，同时只获取到部分图片时，返回 NO</span><br><span class="line"> *          imageURL：图片的URL地址</span><br><span class="line"> *</span><br><span class="line"> * @return SDWebImageOperation对象，应该是SDWebimageDownloaderOperation实例</span><br><span class="line"> */</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    //没有completedblock，那么调用这个方法是毫无意义的</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won&#x27;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    //检查用户传入的URL是否正确，如果该URL是NSString类型的，那么尝试转换</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    //防止因参数类型错误而导致应用程序崩溃，判断URL是否是NSURL类型的，如果不是则直接设置为nil</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化一个SDWebImageCombinedOperationBlock块</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;  //初始化设定该URL是正确的</span><br><span class="line"></span><br><span class="line">    //加互斥锁，检索请求图片的URL是否在曾下载失败的集合中（URL黑名单）</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果url不正确或者 选择的下载策略不是『下载失败尝试重新下载』且该URL存在于黑名单中，那么直接返回，回调任务完成block块，传递错误信息</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line"></span><br><span class="line">        //该宏保证了completedBlock回调在主线程中执行</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加互斥锁，把当前的下载任务添加到『当前正在执行任务数组』中</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    //得到该URL对应的缓存KEY</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">    //该方法查找URLKEY对应的图片缓存是否存在，查找完毕之后把该图片（存在|不存在）和该图片的缓存方法以block的方式传递</span><br><span class="line">    //缓存情况查找完毕之后，在block块中进行后续处理（如果该图片没有缓存·下载|如果缓存存在|如果用户设置了下载的缓存策略是刷新缓存如何处理等等）</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        //先判断该下载操作是否已经被取消，如果被取消则把当前操作从runningOperations数组中移除，并直接返回</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //（图片不存在||下载策略为刷新缓存）且（shouldDownloadImageForURL不能响应||该图片存在缓存）</span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            //从此处开始，一直在处理downloaderOptions（即下载策略）</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;   //如果图像存在，但是下载策略为刷新缓存，则通知缓存图像并尝试重新下载</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            //如果下载策略为SDWebImageLowPriority 那么downloaderOptions = 其本身</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; //如果图片存在，且下载策略为刷新刷新缓存</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                //如果图像已缓存，但需要刷新缓存，那么强制进行刷新</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                //忽略从NSURLCache读取图片</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            //到此处位置，downloaderOptions（即下载策略）处理操作结束</span><br><span class="line"></span><br><span class="line">            //核心方法：使用下载器，下载图片</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                if (weakOperation.isCancelled) &#123;</span><br><span class="line">                    //如果此时操作被取消，那么什么也不做</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) &#123; //如果下载失败，则处理结束的回调，在合适的情况下把对应图片的URL添加到黑名单中</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;//下载成功</span><br><span class="line">                    //先判断当前的下载策略是否是SDWebImageRetryFailed，如果是那么把该URL从黑名单中删除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //是否要进行磁盘缓存？</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    //如果下载策略为SDWebImageRefreshCached且该图片缓存中存在且未下载下来，那么什么都不做</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        //否则，如果下载图片存在且（不是可动画图片数组||下载策略为SDWebImageTransformAnimatedImage&amp;&amp;transformDownloadedImage方法可用）</span><br><span class="line">                        //开子线程处理</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            //在下载后立即将图像转换，并进行磁盘和内存缓存</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            //在主线程中回调completedBlock</span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        //得到下载的图片且已经完成，则进行缓存处理</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:operation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            //处理cancelBlock</span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line"></span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    [self.runningOperations removeObject:weakOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123;   //如果图片存在，且操作没有被取消，那么在主线程中回调completedBlock，并把当前操作移除</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            //图片不存在缓存且不允许代理下载，那么在主线程中回调completedBlock，并把当前操作移除</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缓存及磁盘操作"><a href="#缓存及磁盘操作" class="headerlink" title="缓存及磁盘操作"></a>缓存及磁盘操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//检查要下载图片的缓存情况</span><br><span class="line">/*</span><br><span class="line"> 1.先检查是否有内存缓存</span><br><span class="line"> 2.如果没有内存缓存则检查是否有沙盒缓存</span><br><span class="line"> 3.如果有沙盒缓存，则对该图片进行内存缓存处理并执行doneBlock回调</span><br><span class="line"> */</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line"></span><br><span class="line">    //如果回调不存在，则直接返回</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果缓存对应的key为空，则直接返回，并把存储方式（无缓存）通过block块以参数的形式传递</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    //检查该KEY对应的内存缓存，如果存在内存缓存，则直接返回，并把图片和存储方式（内存缓存）通过block块以参数的形式传递</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     //创建一个操作</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    //使用异步函数，添加任务到串行队列中（会开启一个子线程处理block块中的任务）</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">         //如果当前的操作被取消，则直接返回</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //检查该KEY对应的磁盘缓存</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            //如果存在磁盘缓存，且应该把该图片保存一份到内存缓存中，则先计算该图片的cost(成本）并把该图片保存到内存缓存中</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                //计算图片的Cost</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                //对该图片进行内存缓存处理</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             //线程间通信，在主线程中回调doneBlock，并把图片和存储方式（磁盘缓存）通过block块以参数的形式传递</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注：（磁盘缓存目录）"><a href="#注：（磁盘缓存目录）" class="headerlink" title="注：（磁盘缓存目录）"></a>注：（磁盘缓存目录）</h4><p>缓存在磁盘沙盒目录下 <code>Library/Caches</code><br>二级目录为 <code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark SDImageCache Life Cycle</span><br><span class="line"></span><br><span class="line">//初始化方法，默认的缓存空间名称为default</span><br><span class="line">- (id)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用指定的命名空间实例化一个新的缓存存储</span><br><span class="line">- (id)initWithNamespace:(NSString *)ns &#123;</span><br><span class="line">    //根据传入的命名空间设置磁盘缓存路径</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用指定的命名空间实例化一个新的缓存存储和目录</span><br><span class="line">//拼接完成的结果为：沙盒--》caches路径--》default--》com.hackemist.SDWebImageCache.default</span><br><span class="line">- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line"></span><br><span class="line">        //拼接默认的磁盘缓存目录</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line"></span><br><span class="line">        // initialise PNG signature data</span><br><span class="line">        // 初始化PNG数据签名 8字节</span><br><span class="line">        kPNGSignatureData = [NSData dataWithBytes:kPNGSignatureBytes length:8];</span><br><span class="line"></span><br><span class="line">        // Create IO serial queue</span><br><span class="line">        // 创建处理IO操作的串行队列</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        // Init default values</span><br><span class="line">        // 初始化默认的最大缓存时间 == 1周</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line"></span><br><span class="line">        // Init the memory cache</span><br><span class="line">        // 初始化内存缓存，使用NSCache(AutoPurgeCache)</span><br><span class="line">        _memCache = [[AutoPurgeCache alloc] init];</span><br><span class="line"></span><br><span class="line">        //设置默认的缓存磁盘目录</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // Init the disk cache</span><br><span class="line">        //初始化磁盘缓存，如果磁盘缓存路径不存在则设置为默认值，否则根据命名空间重新设置</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            //以默认值得方式拼接</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据命名空间重新设置</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set decompression to YES</span><br><span class="line">        // 设置图片是否解压缩，默认为YES</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line"></span><br><span class="line">        // memory cache enabled</span><br><span class="line">        // 是否进行内存缓存（默认为YES）</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line"></span><br><span class="line">        // Disable iCloud</span><br><span class="line">        // 是否禁用iCloud备份,默认为YES</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line"></span><br><span class="line">        //同步函数+串行队列：在当前线程中同步的初始化文件管理者</span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            _fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IOS</span><br><span class="line">        // Subscribe to app events</span><br><span class="line">        //监听应用程序通知</span><br><span class="line">        //当监听到UIApplicationDidReceiveMemoryWarningNotification（系统级内存警告）调用clearMemory方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(clearMemory)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        //当监听到UIApplicationWillTerminateNotification（程序将终止）调用cleanDisk方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(cleanDisk)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        //当监听到UIApplicationDidEnterBackgroundNotification（进入后台），调用backgroundCleanDisk方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundCleanDisk)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遇到过的两种需求"><a href="#遇到过的两种需求" class="headerlink" title="遇到过的两种需求"></a>遇到过的两种需求</h4><p>一、图片进过加密处理，一段时间内可以访问，即图片地址后面跟的参数不同，但加载出来的图片是同一张，为了不重复下载，如何过滤图片地址？<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法： 写在viewDidLoad 或者 appDelegate里</span><br><span class="line"></span><br><span class="line">1.版本5.0之前</span><br><span class="line">// URL过滤器</span><br><span class="line">[[SDWebImageManager sharedManager] setCacheKeyFilter:^NSString * _Nullable(NSURL * _Nullable url) &#123;</span><br><span class="line">    // 去除参数 ？后面的</span><br><span class="line">    url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">    return [url relativeString];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">2.版本5.0之后</span><br><span class="line">// URL过滤器</span><br><span class="line">SDWebImageCacheKeyFilter *filter = [[SDWebImageCacheKeyFilter alloc] initWithBlock:^NSString * _Nullable(NSURL * _Nonnull url) &#123;</span><br><span class="line">    // 去除参数 ？后面的</span><br><span class="line">    url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">    return [url relativeString];</span><br><span class="line">&#125;];</span><br><span class="line">[[SDWebImageManager sharedManager] setCacheKeyFilter:filter];</span><br></pre></td></tr></table></figure><br>二、如何做到tableView滚动时 不加载cell中的图片，停止滚动或减速时才加图片？</p>
<p>需要用到的核心方法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> * 根据图片的url下载图片并设置到ImageView上面去，占位图片</span><br><span class="line"> * 异步下载并缓存</span><br><span class="line"> *</span><br><span class="line"> * @param url            图片的URL</span><br><span class="line"> * @param placeholder   显示在UIImageView上面的占位图片，直到图片下载完成</span><br><span class="line"> * @param options       下载图片的选项。参考SDWebImageOptions的枚举值</span><br><span class="line"> * @param completedBlock 当操作执行完毕之后的回调。该回调没有返回值</span><br><span class="line"> *      第一个参数为请求的图片</span><br><span class="line"> *      第二个参数是NSError类型的，如果图片下载成功则error为nil,否则error有值</span><br><span class="line"> *      第三个参数是图片缓存的使用情况（内存缓存|沙盒缓存|直接下载）</span><br><span class="line"> *      第四个参数是图片的URL地址</span><br><span class="line"> */</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options completed:(SDWebImageCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><br>SDWebImageOptions 枚举类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用位移枚举，通过按位与&amp;按位或|的组合方式传递多个值</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won&#x27;t keep trying.</span><br><span class="line">     * This flag disable this blacklisting.</span><br><span class="line">     *</span><br><span class="line">     * 默认情况下，如果一个url在下载的时候失败了，那么这个url会被加入黑名单，不会尝试再次下载。如果使用该参数，则该URL不会被添加到黑名单中。意味着会对下载失败的URL尝试重新下载。</span><br><span class="line">     * 此标记取消黑名单</span><br><span class="line">     */</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0, //失败后尝试重新下载</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * By default, image downloads are started during UI interactions, this flags disable this feature,</span><br><span class="line">     * leading to delayed download on UIScrollView deceleration for instance.</span><br><span class="line">     *</span><br><span class="line">     * 默认情况下，在 UI 交互时也会启动图像下载，此标记取消这一特性</span><br><span class="line">     * 会推迟到滚动视图停止滚动之后再继续下载</span><br><span class="line">     * 备注：NSURLConnection 的网络下载事件监听的运行循环模式是 NSDefaultRunLoopMode</span><br><span class="line">     */</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,//低优先级</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * This flag disables on-disk caching</span><br><span class="line">     *</span><br><span class="line">     * 使用该参数，将禁止磁盘缓存，只做内存缓存</span><br><span class="line">     */</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只使用内存缓存</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * This flag enables progressive download, the image is displayed progressively during download as a browser would do.</span><br><span class="line">     * By default, the image is only displayed once completely downloaded.</span><br><span class="line">     *</span><br><span class="line">     * 此标记允许渐进式下载，就像浏览器中那样，下载过程中，图像会逐步显示出来</span><br><span class="line">     * 默认情况下，图像会在下载完成后一次性显示</span><br><span class="line">     */</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,//渐进式下载</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.</span><br><span class="line">     * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.</span><br><span class="line">     * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.</span><br><span class="line">     * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.</span><br><span class="line">     *</span><br><span class="line">     * Use this flag only if you can&#x27;t make your URLs static with embedded cache busting parameter.</span><br><span class="line">     *</span><br><span class="line">     * 遵守 HTPP 响应的缓存控制，如果需要，从远程刷新图像</span><br><span class="line">     * 磁盘缓存将由 NSURLCache 处理，而不是 SDWebImage，这会对性能有轻微的影响</span><br><span class="line">     * 此选项用于处理URL指向图片发生变化的情况</span><br><span class="line">     * 如果缓存的图像被刷新，会调用一次 completion block，并传递最终的图像</span><br><span class="line">     */</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4, //刷新缓存</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span><br><span class="line">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span><br><span class="line">     *</span><br><span class="line">     * 如果系统版本是iOS 4+的，那么当App进入后台后仍然会继续下载图像。</span><br><span class="line">     * 这是向系统请求额外的后台时间以保证下载请求完成的</span><br><span class="line">     * 如果后台任务过期，请求将会被取消</span><br><span class="line">     */</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,    //后台下载</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Handles cookies stored in NSHTTPCookieStore by setting</span><br><span class="line">     * NSMutableURLRequest.HTTPShouldHandleCookies = YES;</span><br><span class="line">     *</span><br><span class="line">     * 通过设置，处理保存在 NSHTTPCookieStore 中的 cookies</span><br><span class="line">     */</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,    //处理保存在NSHTTPCookieStore中的cookies</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Enable to allow untrusted SSL certificates.</span><br><span class="line">     * Useful for testing purposes. Use with caution in production.</span><br><span class="line">     *</span><br><span class="line">     * 允许不信任的 SSL 证书</span><br><span class="line">     * 可以出于测试目的使用，在正式产品中慎用</span><br><span class="line">     */</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,  //允许不信任的 SSL 证书</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * By default, image are loaded in the order they were queued. This flag move them to</span><br><span class="line">     * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which</span><br><span class="line">     * could take a while).</span><br><span class="line">     *</span><br><span class="line">     *  默认情况下，图像会按照添加到队列中的顺序被加载，此标记会将它们移动到队列前端被立即加载</span><br><span class="line">     *  而不是等待当前队列被加载，因为等待队列加载会需要一段时间</span><br><span class="line">     */</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,     //高优先级（优先下载）</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span><br><span class="line">     * of the placeholder image until after the image has finished loading.</span><br><span class="line">     *</span><br><span class="line">     * 默认情况下，在加载图像时，占位图像已经会被加载。</span><br><span class="line">     * 此标记会延迟加载占位图像，直到图像已经完成加载</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,    //延迟占位图片</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * We usually don&#x27;t call transformDownloadedImage delegate method on animated images,</span><br><span class="line">     * as most transformation code would mangle it.</span><br><span class="line">     * Use this flag to transform them anyway.</span><br><span class="line">     *</span><br><span class="line">     * 通常不会在可动画的图像上调用transformDownloadedImage代理方法，因为大多数转换代码会破坏动画文件</span><br><span class="line">     * 使用此标记尝试转换</span><br><span class="line">     */</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, //转换动画图像</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * By default, image is added to the imageView after download. But in some cases, we want to</span><br><span class="line">     * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance)</span><br><span class="line">     * Use this flag if you want to manually set the image in the completion when success</span><br><span class="line">     *</span><br><span class="line">     * 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上</span><br><span class="line">     */</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11   //手动设置图像</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>参数填成以下就可以了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options: SDWebImageRetryFailed |SDWebImageLowPriority</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode执行代码自动格式化</title>
    <url>/2021/11/03/Xcode%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>因为原作者写的非常详细，直接附上：<a href="https://luisramos.dev/xcode-format-and-save">原文地址</a><br>还有掘金上经过改编的文章：<a href="https://juejin.cn/post/7019111525759582215">Swift代码自动格式化</a></p>
<h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><ul>
<li>SwiftFormat 是一款用来格式化Swift代码的命令行工具。</li>
<li>Automator是一款系统软件，中文名是自动操作。</li>
<li>通过在Xcode中 执行 <code>command+S</code> 保存快捷键，SwiftFormat通过Automator自动执行格式化</li>
</ul>
<span id="more"></span>
<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul>
<li><p>Xcode关闭再打开之后，自动执行格式化可能失效，Automator暂未找到文章中设置过的 <code>AppleScript</code>记录，需要重新激活一下，按路径点击==Xcode -&gt; Services -&gt; XcodeFormatAndSave==就可以正常 <code>command+S</code></p>
</li>
<li><p>之所以不设置成 <code>command+R</code>运行时候格式化，如果有改的地方报错，就是一对多的去改动，最好是完成一个文件格式化后，通过<code>command+S</code>保存 保证一对一及时修改。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>aboutJub</category>
      </categories>
      <tags>
        <tag>SwiftFormat</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 无埋点数据统计方案设计</title>
    <url>/2019/07/03/iOS-%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="先附上参考的文章："><a href="#先附上参考的文章：" class="headerlink" title="先附上参考的文章："></a>先附上参考的文章：</h4><p><a href="https://www.jianshu.com/p/69ce01e15042">iOS无埋点数据SDK实践之路</a><br><a href="https://www.jianshu.com/p/a6afc6252965">iOS无埋点数据统计实践</a></p>
<h4 id="该方案的统计功能？"><a href="#该方案的统计功能？" class="headerlink" title="该方案的统计功能？"></a>该方案的统计功能？</h4><ul>
<li>APP进入前台</li>
<li>按钮点击 （点击次数、按钮名称、点击方法）</li>
<li>cell点击</li>
<li>界面停留时长</li>
<li>APP进入后台</li>
</ul>
<h4 id="如何实现无埋点"><a href="#如何实现无埋点" class="headerlink" title="如何实现无埋点"></a>如何实现无埋点</h4><p>利用运行时机制，将类原生方法替换成用户自定义的方法，相当于强行在原本调用栈中插入一个方法，我们在其中插入一段统计代码即可。</p>
<span id="more"></span>
<h5 id="如何替换方法-Method-Swizzling"><a href="#如何替换方法-Method-Swizzling" class="headerlink" title="如何替换方法:Method Swizzling"></a>如何替换方法:Method Swizzling</h5><p>函数的调用涉及到3个重要的点：Class、SEL、IMP，Calss作为类型，Method由SEL和IMP组成。我们通过交换Method的IMP达到替换被调用函数的目的。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心方法：</span><br><span class="line">- (void)sel_exchangeFirstSel:(SEL)sel1 secondSel:(SEL)sel2 &#123;</span><br><span class="line">    [self sel_exchangeClass:[self class] FirstSel:sel1 secondSel:sel2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sel_exchangeClass:(Class)Class FirstSel:(SEL)sel1 secondSel:(SEL)sel2 &#123;</span><br><span class="line">    Method firstMethod = class_getInstanceMethod(Class, sel1);</span><br><span class="line">    Method secondMethod = class_getInstanceMethod(Class, sel2);</span><br><span class="line">    method_exchangeImplementations(firstMethod, secondMethod);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong><em>注：</em></strong> 这里主要交换的方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">系统类</th>
<th style="text-align:center">类方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UIControl</td>
<td style="text-align:center">sendAction:to:forEvent</td>
</tr>
<tr>
<td style="text-align:center">UIGestureRecognizer</td>
<td style="text-align:center">addTarget:action:</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">initWithTarget:action:</td>
</tr>
<tr>
<td style="text-align:center">UIView</td>
<td style="text-align:center">addGestureRecognizer</td>
</tr>
<tr>
<td style="text-align:center">UITableView</td>
<td style="text-align:center">setDelegate</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">tableView:didSelectRowAtIndexPath:</td>
</tr>
<tr>
<td style="text-align:center">NSNotificationCenter</td>
<td style="text-align:center">postNotification</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">postNotificationName:object:userInfo:</td>
</tr>
<tr>
<td style="text-align:center">UIViewController</td>
<td style="text-align:center">viewDidAppear:</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">viewDidDisappear:</td>
</tr>
</tbody>
</table>
<h5 id="swizzling函数的时机"><a href="#swizzling函数的时机" class="headerlink" title="swizzling函数的时机"></a>swizzling函数的时机</h5><p>+(void)load函数在你动态加载或者静态引用了这个类的时候，该函数就会被执行，它并不需要你显示的去创建一个类后才会执行，同时它只会执行一次，几乎是完美的swizzling时机。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例 UIControl</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        //创建新的sendAction:to:forEvent:方法</span><br><span class="line">        [self sel_exchangeFirstSel:@selector(sendAction:to:forEvent:) secondSel:@selector(ch_sendAction:to:forEvent:)];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="加入数据统计代码"><a href="#加入数据统计代码" class="headerlink" title="加入数据统计代码"></a>加入数据统计代码</h5><p>在swizzling成功后，我们在其中加入统计代码。为了保证响应链的完整，我们还需要调用替换过的方法，让事件传递下去，不去影响系统的处理。</p>
<ul>
<li>这里采用 <code>内联函数</code> 将该方法包起来使用 用于过滤黑名单（不参与统计的控制器）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 黑名单 不需要追踪的控制器 */</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">UIKIT_STATIC_INLINE BOOL kShouldTrackClass(Class aClass)&#123;</span><br><span class="line">    static NSSet *blacklistedClasses = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">//        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;BlackListed&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">//        NSArray *blacklistedClassNames = [NSArray arrayWithContentsOfFile:path];</span><br><span class="line">        </span><br><span class="line">        NSArray *blacklistedClassNames = [LogDAO sharedInstance].blackListArray;</span><br><span class="line">        NSMutableSet *transformedClasses = [NSMutableSet setWithCapacity:blacklistedClassNames.count];</span><br><span class="line">        for (NSString *className in blacklistedClassNames) &#123;</span><br><span class="line">            [transformedClasses addObject:NSClassFromString(className)];</span><br><span class="line">        &#125;</span><br><span class="line">        blacklistedClasses = [transformedClasses copy];</span><br><span class="line">    &#125;);</span><br><span class="line">    return ![blacklistedClasses containsObject:aClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="统计方式：操作数据库"><a href="#统计方式：操作数据库" class="headerlink" title="统计方式：操作数据库"></a>统计方式：操作数据库</h5><ul>
<li>数据库地址：<code>/var/mobile/Containers/Data/Application/······/Library/Caches/TheOnlineTax/Database/log.sqlite</code></li>
<li>数据库表名为 <code>info_log</code></li>
<li>表中的参数 也是模型中的属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, LogType) &#123;</span><br><span class="line">    LogTypeNone = 0,    // 未知</span><br><span class="line">    LogTypeLaunch,      // app 启动或前台</span><br><span class="line">    LogTypeButtonClick, // 按钮点击</span><br><span class="line">    LogTypeCellClick,   // cell点击</span><br><span class="line">    LogTypeVCRemainTime,// 界面停留时间</span><br><span class="line">    LogTypeTerminated,  // app 终止或后台</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *vc_id;// 控制器名称 </span><br><span class="line">@property (nonatomic) NSTimeInterval remainTime; //停留时间</span><br><span class="line">@property (nonatomic, copy) NSString *btn_id;// 按钮名称</span><br><span class="line">@property (nonatomic, copy) NSString *functionName;// 方法名称</span><br><span class="line">@property (nonatomic, assign) NSInteger num;// 点击次数</span><br><span class="line">@property (nonatomic) NSTimeInterval lastTime; //最后执行时间</span><br><span class="line">@property (nonatomic, assign) LogType logType; //记录类型</span><br></pre></td></tr></table></figure>
<ul>
<li>插入之前会判断是否存在 若存在只更新表</li>
<li>按钮次数 是通过 vc_id 和 btn_id 进行查表 累加所得</li>
<li>具体逻辑可看LogDAO文件</li>
</ul>
<h5 id="数据上传服务器"><a href="#数据上传服务器" class="headerlink" title="数据上传服务器"></a>数据上传服务器</h5><p>因没有后台存储这些统计出来的数据，暂时使用后端云Bmob存储</p>
<ul>
<li>触发上传的时机</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目前设计 (上传成功数据库的表里数据清空)</span><br><span class="line">1.是APP进入后台自动触发触发 </span><br><span class="line">2.用户退出登录操作触发</span><br></pre></td></tr></table></figure>
<ul>
<li>上传的拼接数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *userID = @&quot;0&quot;;//必须默认0</span><br><span class="line">    if ([AppDelegate trackGetUserID].length&gt;0) &#123;</span><br><span class="line">        userID = [AppDelegate trackGetUserID];</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dic = @&#123;</span><br><span class="line">                          //模型数组转成字典数组</span><br><span class="line">                          @&quot;list&quot; : [LogDTO mj_keyValuesArrayWithObjectArray:[[LogDAO sharedInstance] getAllData]],</span><br><span class="line">                          //应用名称</span><br><span class="line">                          @&quot;productName&quot; : kDisplayName,</span><br><span class="line">                          //bundleId</span><br><span class="line">                          @&quot;productID&quot; : [[NSBundle mainBundle] bundleIdentifier],</span><br><span class="line">                          //应用版本号</span><br><span class="line">                          @&quot;version&quot; : kVersion,</span><br><span class="line">                          //设备版本</span><br><span class="line">                          @&quot;osVersion&quot; : [NSString stringWithFormat:@&quot;%.1f&quot;,[DeviceAndSystemTool systemVersion]],</span><br><span class="line">                          //设备机型</span><br><span class="line">                          @&quot;osDeviceType&quot; : KStringIsEmpty([DeviceAndSystemTool getDeviceName]),</span><br><span class="line">                          //网络类型</span><br><span class="line">                          @&quot;networkType&quot; : KStringIsEmpty([DeviceAndSystemTool networkTypeName]),</span><br><span class="line">                          //运营商</span><br><span class="line">                          @&quot;isp&quot; : KStringIsEmpty([DeviceAndSystemTool wsd_telephonyNetworkInfo]),</span><br><span class="line">                          //定位（省市区）</span><br><span class="line">                          @&quot;gps&quot; : KStringIsEmpty(self.strLocationInfo)</span><br><span class="line">                          &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>APP启动会先获取服务器的数据 若有只在原有基础上更新不会新增一条数据（改动是TrackData和updateAT字段）会根据UserID字段区分数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 新增一条数据 */</span><br><span class="line"></span><br><span class="line">    BmobObject *trackBmob = [BmobObject objectWithClassName:@&quot;TrackAction&quot;];</span><br><span class="line">    [trackBmob setObject:dic forKey:@&quot;TrackData&quot;];</span><br><span class="line">    [trackBmob setObject:[AppDelegate trackGetUserID] forKey:@&quot;UserID&quot;];</span><br><span class="line">    [trackBmob saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) &#123;</span><br><span class="line">        //进行操作</span><br><span class="line">        if (isSuccessful) &#123;</span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(YES,nil);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(NO,error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 更新一条数据 */</span><br><span class="line"></span><br><span class="line">//创建查表对象</span><br><span class="line">    BmobQuery   *bquery = [BmobQuery queryWithClassName:@&quot;TrackAction&quot;];</span><br><span class="line">    //设置查询中该字段是有值的结果</span><br><span class="line">    [bquery whereKeyExists:@&quot;UserID&quot;];</span><br><span class="line">    //设置查询中该字段 值是否相等的结果</span><br><span class="line">    [bquery whereKey:@&quot;UserID&quot; equalTo:[AppDelegate trackGetUserID]];</span><br><span class="line">    //查询</span><br><span class="line">    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) &#123;</span><br><span class="line">        if (error)&#123;</span><br><span class="line">            //进行错误处理</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if (array) &#123;</span><br><span class="line">                BmobObject *obj = array[0];</span><br><span class="line"></span><br><span class="line">                NSString *userID = @&quot;0&quot;;//必须默认0</span><br><span class="line">                if ([AppDelegate trackGetUserID].length&gt;0) &#123;</span><br><span class="line">                    userID = [AppDelegate trackGetUserID];</span><br><span class="line">                &#125;</span><br><span class="line">                NSDictionary *dic = @&#123;</span><br><span class="line">                                      //模型数组转成字典数组</span><br><span class="line">                                      @&quot;list&quot; : [LogDTO mj_keyValuesArrayWithObjectArray:[[LogDAO sharedInstance] getAllData]],</span><br><span class="line">                                      //userid</span><br><span class="line">                                      @&quot;userid&quot; : KStringIsEmpty(userID),</span><br><span class="line">                                      //应用名称</span><br><span class="line">                                      @&quot;productName&quot; : kDisplayName,</span><br><span class="line">                                      //bundleId</span><br><span class="line">                                      @&quot;productID&quot; : [[NSBundle mainBundle] bundleIdentifier],</span><br><span class="line">                                      //应用版本号</span><br><span class="line">                                      @&quot;version&quot; : kVersion,</span><br><span class="line">                                      //设备版本</span><br><span class="line">                                      @&quot;osVersion&quot; : [NSString stringWithFormat:@&quot;%.1f&quot;,[DeviceAndSystemTool systemVersion]],</span><br><span class="line">                                      //设备机型</span><br><span class="line">                                      @&quot;osDeviceType&quot; : KStringIsEmpty([DeviceAndSystemTool getDeviceName]),</span><br><span class="line">                                      //网络类型</span><br><span class="line">                                      @&quot;networkType&quot; : KStringIsEmpty([DeviceAndSystemTool networkTypeName]),</span><br><span class="line">                                      //运营商</span><br><span class="line">                                      @&quot;isp&quot; : KStringIsEmpty([DeviceAndSystemTool wsd_telephonyNetworkInfo]),</span><br><span class="line">                                      //定位（省市区）</span><br><span class="line">                                      @&quot;gps&quot; : KStringIsEmpty(self.strLocationInfo)</span><br><span class="line">                                      &#125;;</span><br><span class="line"></span><br><span class="line">                BmobObject *obj1 = [BmobObject objectWithoutDataWithClassName:obj.className objectId:obj.objectId];</span><br><span class="line">                //设置cheatMode为YES</span><br><span class="line">                [obj1 setObject:dic forKey:@&quot;TrackData&quot;];</span><br><span class="line">                //异步更新数据</span><br><span class="line">                [obj1 updateInBackground];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h4 id="引用方法："><a href="#引用方法：" class="headerlink" title="引用方法："></a>引用方法：</h4><p>目前没有集成到pod上 只能手动导入 这是相关文件：<a href="https://github.com/NickChenHao/TrackAction.git">GitHub</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【 使用说明 】</span><br><span class="line"> 1.需要依赖 pod &#x27;MJExtension&#x27; 和 pod &#x27;AFNetworking&#x27; 请确保项目中已有</span><br><span class="line"> 2.将文件拖入项目中</span><br><span class="line"> 3.需在pch文件中引用  #import &quot;TrackAction.h&quot;</span><br><span class="line"> 4.需在AppDelegate.m文件中</span><br><span class="line">   a.调用 createTablesNeeded 创建数据库</span><br><span class="line">   b.重写 trackGetUserID     配置userID</span><br><span class="line">   c.重写 trackServiceURL    配置上传服务器的地址</span><br><span class="line"> 5.可添加不需要统计的控制器在BlackListed.plist</span><br></pre></td></tr></table></figure>
<h4 id="更新部分【重要】"><a href="#更新部分【重要】" class="headerlink" title="更新部分【重要】"></a>更新部分【重要】</h4><h5 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a><del>引用方法</del></h5><ul>
<li>手动导入 这是相关文件：<a href="https://github.com/NickChenHao/TrackAction.git">GitHub</a></li>
<li>引用svn私有库 <code>pod &#39;ASTrackAction&#39;,&#39;1.0.0&#39;</code></li>
</ul>
<h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a><del>使用说明</del></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【 使用说明 】</span><br><span class="line"> 1.依赖 pod &#x27;MJExtension&#x27; 和 pod &#x27;AFNetworking&#x27;</span><br><span class="line"> 2.需在pch文件中引用  #import &quot;TrackAction.h&quot;</span><br><span class="line"> 3.需在AppDelegate里的方法实现 配置track信息的方法 在LogDAO类中 （不开启埋点功能 注释即可）</span><br></pre></td></tr></table></figure>
<h5 id="上传的拼接数据"><a href="#上传的拼接数据" class="headerlink" title="上传的拼接数据"></a><del>上传的拼接数据</del></h5><p>修改为<br>1.先判断是开启埋点功能<br>2.再判断是否自定义服务器地址 若有则AFN请求 若无则上传至Bmob后端云</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    if (!self.isOpenTracker) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *userID = @&quot;0&quot;;//必须默认0</span><br><span class="line">    if (self.userId.length&gt;0) &#123;</span><br><span class="line">        userID = self.userId;</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dic = @&#123;</span><br><span class="line">                          //模型数组转成字典数组</span><br><span class="line">                          @&quot;list&quot; : [LogDTO mj_keyValuesArrayWithObjectArray:[[LogDAO sharedInstance] getAllData]],</span><br><span class="line">                          //userid</span><br><span class="line">                          @&quot;userid&quot; : KStringIsEmpty(userID),</span><br><span class="line">                          //应用名称</span><br><span class="line">                          @&quot;productName&quot; : kDisplayName,</span><br><span class="line">                          //bundleId</span><br><span class="line">                          @&quot;productID&quot; : [[NSBundle mainBundle] bundleIdentifier],</span><br><span class="line">                          //应用版本号</span><br><span class="line">                          @&quot;version&quot; : kVersion,</span><br><span class="line">                          //设备版本</span><br><span class="line">                          @&quot;osVersion&quot; : [NSString stringWithFormat:@&quot;%.1f&quot;,[DeviceAndSystemTool systemVersion]],</span><br><span class="line">                          //设备机型</span><br><span class="line">                          @&quot;osDeviceType&quot; : KStringIsEmpty([DeviceAndSystemTool getDeviceName]),</span><br><span class="line">                          //网络类型</span><br><span class="line">                          @&quot;networkType&quot; : KStringIsEmpty([DeviceAndSystemTool networkTypeName]),</span><br><span class="line">                          //运营商</span><br><span class="line">                          @&quot;isp&quot; : KStringIsEmpty([DeviceAndSystemTool wsd_telephonyNetworkInfo]),</span><br><span class="line">                          //定位（省市区）</span><br><span class="line">                          @&quot;gps&quot; : KStringIsEmpty(self.strLocationInfo)</span><br><span class="line">                          &#125;;</span><br><span class="line"></span><br><span class="line">    if (!ISEMPTY(self.serviceURL)) &#123;</span><br><span class="line">#pragma mark - AFN</span><br><span class="line"></span><br><span class="line">        [TrackActionServiceManager postParameter:dic Success:^(NSURLSessionDataTask *operation, id responseObject) &#123;</span><br><span class="line"></span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(YES,nil);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; Failure:^(NSURLSessionDataTask *operation, NSError *error) &#123;</span><br><span class="line"></span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(NO,error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">#pragma mark - 后端云SDK</span><br><span class="line"></span><br><span class="line">        BmobObject *trackBmob = [BmobObject objectWithClassName:@&quot;TrackAction&quot;];</span><br><span class="line">        [trackBmob setObject:dic forKey:@&quot;TrackData&quot;];</span><br><span class="line">        [trackBmob setObject:self.userId forKey:@&quot;UserID&quot;];</span><br><span class="line">        [trackBmob saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) &#123;</span><br><span class="line">            //进行操作</span><br><span class="line">            if (isSuccessful) &#123;</span><br><span class="line">                if (handler) &#123;</span><br><span class="line">                    handler(YES,nil);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if (handler) &#123;</span><br><span class="line">                    handler(NO,error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>sonar代码检测插件</title>
    <url>/2019/08/27/sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>SonarQube®是一种自动代码审查工具，用于检测代码中的错误，漏洞和代码异味。它可以与您现有的工作流程集成，以便在项目分支和拉取请求之间进行连续的代码检查。</p>
<span id="more"></span>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/6b61783b9a38">基于Sonar的iOS代码质量检测系统</a><br><a href="https://www.jianshu.com/p/b41262fca5b8">mac搭建SonarQube</a><br><a href="https://www.jianshu.com/p/7f3b08e3a479">iOS mac sonar安装指南</a><br><a href="https://www.jianshu.com/p/3b70aa6af07b">Objective C接入Sonar代码扫描</a></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><h5 id="演示版本："><a href="#演示版本：" class="headerlink" title="演示版本："></a>演示版本：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK：1.8.0_221</span><br><span class="line">MySQL：5.7.27</span><br><span class="line">Sonarqube：7.1</span><br><span class="line">Sonar-runner：2.4</span><br><span class="line">Sonar-scanner：3.3.0.1492-macosx</span><br></pre></td></tr></table></figure>
<h5 id="Java环境与MySQL安装"><a href="#Java环境与MySQL安装" class="headerlink" title="Java环境与MySQL安装"></a>Java环境与MySQL安装</h5><ul>
<li>进入<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">jdk1.8</a>安装界面,下载macos版本</li>
<li>进入<a href="https://dev.mysql.com/downloads/mysql/5.6.html#downloads">MySQL</a>下载界面，下载之后安装，安装完成后，进入系统偏好设置，可看到MySql选项，代表已安装成功 </li>
</ul>
<h5 id="需要的插件"><a href="#需要的插件" class="headerlink" title="需要的插件"></a>需要的插件</h5><ul>
<li><p>sonarqube</p>
<ul>
<li><a href="https://www.sonarqube.org/downloads/">服务端 sonarqube</a> </li>
<li><a href="http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.3/sonar-runner-dist-2.4.zip">客户端 sonar-runner</a> 解压路径：/user/local</li>
</ul>
</li>
<li><p>Sonar-Scanner<br>下载解压到/usr/local  <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner">Sonar-Scanner</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install sonar-scanner</span><br></pre></td></tr></table></figure></li>
<li>Xcpretty</li>
</ul>
<p>最新方法： <code>sudo gem install xcpretty -n/usr/local/bin</code><br>旧方法：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Backelite/xcpretty.git</span><br><span class="line">cd xcpretty</span><br><span class="line">git checkout fix/duration_of_failed_tests_workaround</span><br><span class="line">gem build xcpretty.gemspec</span><br><span class="line">sudo gem install --both xcpretty-0.2.2.gem -n/usr/local/bin</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>OCLint</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap oclint/formulae    </span><br><span class="line">brew install oclint</span><br></pre></td></tr></table></figure>
<p>检查路径：/usr/local/Cellar/oclint/0.13</p>
</li>
<li><p>slather</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gem install slather</span><br></pre></td></tr></table></figure></li>
<li>lizard<ul>
<li><code>sudo pip install lizard</code></li>
<li>若没有安装pip 下载文件 <a href="/download/get-pip.py">get-pip.py</a></li>
<li>并执行<code>sudo python get-pip.py</code></li>
</ul>
</li>
<li>sonar-objective-c-plugin-0.5.0-SNAPSHOT.jar<br>插件下载地址:<a href="https://github.com/ChenTF/iOS-sonarShell">https://github.com/ChenTF/iOS-sonarShell</a><br>解压放在：sonarqube-7.1/extensions/plugins/</li>
</ul>
<h5 id="最后环境目录组成-usr-local"><a href="#最后环境目录组成-usr-local" class="headerlink" title="最后环境目录组成 /usr/local"></a>最后环境目录组成 /usr/local</h5><p><img src="/images/sonar目录.png" alt="sonar目录"></p>
<h4 id="创建MySQL数据库"><a href="#创建MySQL数据库" class="headerlink" title="创建MySQL数据库"></a>创建MySQL数据库</h4> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql-5.7.27-macos10.14-x86_64/bin</span><br><span class="line"></span><br><span class="line">mysql -u root -p </span><br><span class="line">mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; CREATE USER &#x27;sonar&#x27; IDENTIFIED BY &#x27;sonar&#x27;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &#x27;sonar&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;sonar&#x27;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &#x27;sonar&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;sonar&#x27;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><ul>
<li>修改confsonar.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonarqube-7.1/confsonar.properties</span><br><span class="line"></span><br><span class="line">sonar.host.url=http://localhost:9000/sonarqube</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br></pre></td></tr></table></figure>
<ul>
<li>修改wrapper.conf</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonarqube-7.1/wrapper.conf </span><br><span class="line">wrapper.java.command=/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java</span><br></pre></td></tr></table></figure>
<ul>
<li>修改sonar.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonarqube-7.1/conf/sonar.properties</span><br><span class="line"></span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</span><br><span class="line">sonar.jdbc.maxActive=60</span><br><span class="line">sonar.jdbc.maxIdle=5</span><br><span class="line">sonar.jdbc.minIdle=2</span><br><span class="line">sonar.jdbc.maxWait=5000</span><br><span class="line">sonar.jdbc.minEvictableIdleTimeMillis=600000</span><br><span class="line">sonar.jdbc.timeBetweenEvictionRunsMillis=30000</span><br></pre></td></tr></table></figure>
<ul>
<li>修改sonar-runner.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonar-runner-2.4/conf/sonar-runner.properties</span><br><span class="line"></span><br><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 sonar-scanner.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#----- Default SonarQube server</span><br><span class="line">sonar.host.url=http://localhost:9000/sonarqube</span><br><span class="line"></span><br><span class="line">#----- Default source code encoding</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br></pre></td></tr></table></figure>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export OCLINT_HOME=/usr/local/Cellar/oclint/0.13</span><br><span class="line">export PATH=$OCLINT_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">退出  :wq</span><br><span class="line">保存  source ~/.bash_profile</span><br><span class="line">验证  sonar-runner -version</span><br></pre></td></tr></table></figure>
<p><strong>注：检查JAVA_HOME 和 OCLINT_HOME 的路径是否正确 可能有不同</strong></p>
<p>修改完成保存后，终端执行<br><code>cd /usr/local/sonarqube-7.1/bin/macosx-universal-64</code> 和 <code>./sonar.sh start</code><br>打开浏览器访问<a href="http://localhost:9000">http://localhost:9000</a> 若正常进入则配置成功</p>
<p><strong>安装中文插件</strong><br><img src="https://upload-images.jianshu.io/upload_images/6693936-15f9b678d17617f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p>
<h4 id="项目内需要的两个文件（根目录）"><a href="#项目内需要的两个文件（根目录）" class="headerlink" title="项目内需要的两个文件（根目录）"></a>项目内需要的两个文件（根目录）</h4><p><a href="/download/run-sonar.sh">run-sonar.sh</a><br><a href="/download/sonar-project.properties">sonar-project.properties</a>（可修改对应的项目名称、版本号）</p>
<p>启动sonar<br><code>cd /usr/local/sonarqube-7.1/bin/macosx-universal-64</code> 和 <code>./sonar.sh start</code><br>最后在项目根目录执行<br><code>./run-sonar.sh</code></p>
<h3 id="安装执行过程中的命令"><a href="#安装执行过程中的命令" class="headerlink" title="安装执行过程中的命令"></a>安装执行过程中的命令</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>查看数据库<br><code>SHOW DATABASES;</code><br>删除数据库<br><code>DROP DATABASE sonar;</code><br>查看账户<br><code>select user,host from user;</code><br>删除账户<br><code>delete from mysql.user where user=&#39;sonar&#39;;</code><br>启动<br><code>sudo /usr/local/mysql/support-files/mysql.server start</code><br>停止<br><code>sudo /usr/local/mysql/support-files/mysql.server stop</code><br>重启<br><code>sudo /usr/local/mysql/support-files/mysql.server restart</code></p>
<p><strong>注：</strong> <a href="https://www.jianshu.com/p/4cc5640eec4b">完全卸载MAC上的mysql</a></p>
<h4 id="sonarqube"><a href="#sonarqube" class="headerlink" title="sonarqube"></a>sonarqube</h4><p><code>cd /usr/local/sonarqube-7.1/bin/macosx-universal-64</code><br>启动<br><code>./sonar.sh start</code><br>停止<br><code>./sonar.sh stop</code><br>重启<br><code>./sonar.sh restart</code></p>
<h3 id="安装执行过程中的问题"><a href="#安装执行过程中的问题" class="headerlink" title="安装执行过程中的问题"></a>安装执行过程中的问题</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main ERROR Null object returned for RollingFile in Appenders.</span><br><span class="line">main ERROR Unable to locate appender &quot;file_es&quot; for logger config &quot;root&quot;</span><br></pre></td></tr></table></figure>
<p>解决：需要将配置文件log4j2.properties  中<code>logger.deprecation.level=warn</code>  改为 ERROR   ( 文件位置<code>/user/local/sonarqube-7.1/temp</code>)  <strong>若没有该设置 直接添加</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WrapperSimpleApp: Encountered an error running main: java.nio.file.AccessDeniedException:</span><br></pre></td></tr></table></figure>
<p>解决：删除 <code>/user/local/sonarqube-7.1/temp</code> 文件下所有内容即可</p>
<hr>
<p>mac下安装mysql，连接出现Access denied for user ‘root‘@’localhost’ (using password: YES)<br>解决：<a href="https://blog.csdn.net/lyl123_456/article/details/82426212">https://blog.csdn.net/lyl123_456/article/details/82426212</a></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: Re-run SonarQube Scanner using the -X switch to enable full debug logging.ERROR: SonarQube scanner exited with non-zero code: 1Finished: FAILURE</span><br></pre></td></tr></table></figure>
<p>解决：<img src="/images/sonarqube配置.png" alt="问题解决"></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Another active Homebrew update process is already in progress. Please wait for it to finish or terminate it to continue.</span><br></pre></td></tr></table></figure>
<p>解决： 执行 <code>rm -rf /usr/local/var/homebrew/locks</code></p>
<hr>
<p>扫描成功后最后查看网站，代码重复率有数字，其他代码质量为0<br>解决：查看project：sonar-project.properties文件，配置这2句 可以尝试。。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sonar.objectivec.oclint.report=oclint.xml（这个是报告的名字）</span><br><span class="line">sonar.objectivec.oclint.reportPath=sonar-reports/oclint.xml（这个是报告的路径）</span><br></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1046 (3D000): No database selected</span><br></pre></td></tr></table></figure>
<p>解决： <code>mysql&gt; use mysql</code></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1396 (HY000): Operation CREATE USER failed for &#x27;sonar&#x27;@&#x27;%&#x27;</span><br></pre></td></tr></table></figure>
<p>解决：换个名称<code>CREATE USER &#39;sonarqube&#39; IDENTIFIED BY &#39;sonarqube&#39;;</code></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.FileNotFoundException: /usr/local/sonarqube-7.1/extensions/plugins/sonar-objective-c-plugin-0.5.0-SNAPSHOT.jar (No such file or directory)</span><br></pre></td></tr></table></figure>
<p>解决：冲突 去掉对应的文件 重新运行sonar</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: can not run elasticsearch as root</span><br></pre></td></tr></table></figure>
<p>解决：运行命令将<code>sudo /usr/local//sonarqube-7.1/bin/macosx-universal-64/sonar.sh start</code> 修改为 <code>cd /usr/local//sonarqube-7.1/bin/macosx-universal-64</code>  和  <code>./sonar.sh start</code> </p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若项目根目录 执行 ./run-sonar.sh 出错 -bash: ./run-sonar.sh: Permission denied  </span><br></pre></td></tr></table></figure>
<p>解决：<code>chmod u=rxw run-sonar.sh</code> 修改权限</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: one compiler command contains multiple jobs:  </span><br></pre></td></tr></table></figure>
<p>解决：<br>     •    将 Project 和 Targets 中 Building Settings 下的 COMPILER_INDEX_STORE_ENABLE 设置为 NO<br>     •    在 podfile 中 target ‘xx’ do 前面添加下面的脚本<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">    installer.pods_project.targets.each do |target|</span><br><span class="line">        target.build_configurations.each do |config|</span><br><span class="line">            config.build_settings[&#x27;COMPILER_INDEX_STORE_ENABLE&#x27;] = &quot;NO&quot;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<hr>
]]></content>
      <categories>
        <category>代码质量检测</category>
      </categories>
      <tags>
        <tag>sonar</tag>
      </tags>
  </entry>
  <entry>
    <title>swift笔记1</title>
    <url>/2016/01/25/swift/</url>
    <content><![CDATA[<h2 id="Swift最基本的语法变化"><a href="#Swift最基本的语法变化" class="headerlink" title="Swift最基本的语法变化"></a>Swift最基本的语法变化</h2><ul>
<li>导入框架 import UIKit</li>
<li><p>定义标识符时，必须声明该标识符是变量还是常量声明标识符的<br>格式:变量/常量关键字 名称 : 数据类型</p>
</li>
<li><p>语句结束时不需要加 ;如果同一行有多个语句,则依然需要加<br>但是不建议一行多条语句</p>
</li>
<li><p>Swift中的打印语句: print(“打印的内容”)</p>
<span id="more"></span>
<h2 id="什么是常量和变量"><a href="#什么是常量和变量" class="headerlink" title="什么是常量和变量"></a>什么是常量和变量</h2></li>
<li><p>在Swift中规定:在定义一个标识符时必须明确说明该标识符是一个常量还是变量<br>1.使用let来定义常量,定义之后不可以修改<br>2.使用var来定义变量,定义之后可以修改</p>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>在真实使用过程中,建议先定义常量,如果需要修改再修改为变量(更加安全)<br>是指向的对象不可以再进行修改.但是可以通过指针获得对象后,修改对象内部的属性</p>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>Swift是强类型的语言<br>Swift中任何一个标识符都有明确的类型</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h4><p>1.如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.<br>2.因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型 可以通过option+鼠标左键 来查看变量的数据类型 </p>
<h2 id="Swift中基本运算"><a href="#Swift中基本运算" class="headerlink" title="Swift中基本运算"></a>Swift中基本运算</h2><p>1.Swift中在进行基本运算时必须保证类型一致,否则会出错相同类型之间才可以进行运算<br>因为Swift中没有隐式转换</p>
<p>2.数据类型的转化Int类型转成Double类型:Double(标识符)<br>Double类型转成Int类型:Int(标识符)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 10</span><br><span class="line">let b = 3.14</span><br><span class="line">// 错误写法 </span><br><span class="line">//let c = a + b </span><br><span class="line">//let c = a * b</span><br><span class="line">// 正确写法</span><br><span class="line">let c = Double(a) + blet </span><br><span class="line">d = a + Int(b)</span><br></pre></td></tr></table></figure>
<p>if分支语句<br>和OC中if语句有一定的区别判断句可以不加()<br>在Swift的判断句中必须有明确的真假不再有非0即真<br>必须有明确的Bool值<br>Bool有两个取值:false/true</p>
<h2 id="guard的使用"><a href="#guard的使用" class="headerlink" title="guard的使用"></a>guard的使用</h2><p>guard语句必须带有else语句，它的语法如下：当条件表达式为true时候跳过else语句中的内容，执行语句组内容<br>条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guard 条件表达式 else &#123;  // 条换语句 </span><br><span class="line">  break&#125;</span><br><span class="line">语句组</span><br></pre></td></tr></table></figure>
<h2 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h2><p>基本用法和OC用法一致<br>不同之处:switch后可以不跟()<br>case后可以不跟break(默认会有break)</p>
<h4 id="简单使用补充"><a href="#简单使用补充" class="headerlink" title="简单使用补充:"></a>简单使用补充:</h4><p>1.一个case判断中,可以判断多个值<br>多个值以, 隔开 如果希望出现之前的case穿透,则可以使用关键字fallthrough</p>
<p>2.什么是区间?通常我们指的是数字区间:0~10,100~200</p>
<p>3.swift中的区间常见有两种半开半闭区间:0..&lt;10 表示:0~9,不包括10<br>闭区间:0…10 表示:0~10</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let score = 88switch score &#123;</span><br><span class="line">    case 0..&lt;60:    </span><br><span class="line">        print(&quot;不及格&quot;)</span><br><span class="line">    case 60..&lt;80:    </span><br><span class="line">        print(&quot;几个&quot;)</span><br><span class="line">    case 80..&lt;90:    </span><br><span class="line">        print(&quot;良好&quot;)</span><br><span class="line">    case 90..&lt;100:    </span><br><span class="line">        print(&quot;优秀&quot;)</span><br><span class="line">    default:   </span><br><span class="line">        print(&quot;满分&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环的介绍"><a href="#循环的介绍" class="headerlink" title="循环的介绍"></a>循环的介绍</h2><ul>
<li>在开发中经常会需要循环</li>
<li>常见的循环有:for/while/do while.</li>
<li>这里我们只介绍for/while,因为for/while最常见</li>
</ul>
<h2 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h2><ul>
<li>最常规写法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">for var i = 0; i &lt; 10; i++ &#123; </span><br><span class="line">     print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>区间for循环</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//半开半闭区间</span><br><span class="line">for i in 0..&lt;10 &#123; </span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">//闭区间</span><br><span class="line">for i in 0...10 &#123; </span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特殊写法如果在for循环中不需要用到下标i</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for _ in 0..&lt;10 &#123; </span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while和do-while循环"><a href="#while和do-while循环" class="headerlink" title="while和do while循环"></a>while和do while循环</h2><ul>
<li>while循环<ul>
<li>while的判断句必须有正确的真假,没有非0即真</li>
<li>while后面的()可以省略</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">while a &lt; 10 &#123; </span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do while循环使用<ul>
<li>repeat关键字来代替了do</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let b = 0</span><br><span class="line">repeat &#123; </span><br><span class="line">    print(b)</span><br><span class="line">    b++</span><br><span class="line">&#125; while b &lt; 20</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>swift笔记2</title>
    <url>/2016/01/26/swift%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="字符串的介绍"><a href="#字符串的介绍" class="headerlink" title="字符串的介绍"></a>字符串的介绍</h3><ul>
<li>字符串在任何的开发中使用都是非常频繁的</li>
<li>OC和Swift中字符串的区别<ul>
<li>在OC中字符串类型时NSString,在Swift中字符串类型是String</li>
<li>OC中字符串@””,Swift中字符串””</li>
</ul>
</li>
<li><p>使用 String 的原因</p>
<ul>
<li>String 是一个结构体，性能更高</li>
<li>NSString 是一个 OC 对象，性能略差</li>
<li>String 支持直接遍历</li>
<li>Swift 提供了 String 和 NSString 之间的无缝转换</li>
</ul>
<span id="more"></span>
</li>
</ul>
<h3 id="字符的定义"><a href="#字符的定义" class="headerlink" title="字符的定义"></a>字符的定义</h3><ul>
<li><p>定义不可变字符串<br><code>let str = &quot;hello Objective-C&quot;</code></p>
</li>
<li><p>定义可变字符串<br><code>var str = &quot;hello Swift&quot;</code></p>
</li>
</ul>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p>获取字符串的长度</p>
<ul>
<li><p>获取字符集合,再获取集合的count属性<br><code>let count = str.characters.count</code></p>
</li>
<li><p>遍历字符串</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;Hello, Swift&quot;</span><br><span class="line">for c in str.characters &#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li>两个字符串的拼接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str1 = &quot;Hello&quot;</span><br><span class="line">let str2 = &quot;World&quot;</span><br><span class="line">let str3 = str1 + str2</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串和其他数据类型的拼接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &quot;why&quot; </span><br><span class="line">let age = 18 </span><br><span class="line">let info = &quot;my name is \(name), age is \(age)&quot; </span><br></pre></td></tr></table></figure>
<ul>
<li>字符串的格式化<ul>
<li>比如时间:03:04</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let min = 3</span><br><span class="line">let second = 4</span><br><span class="line">let time = String(format: &quot;%02d:%02d&quot;, arguments: [min, second])</span><br></pre></td></tr></table></figure>
<p>###字符串的截取</p>
<ul>
<li>Swift中提供了特殊的截取方式<ul>
<li>该方式非常麻烦</li>
<li>Index创建较为麻烦</li>
</ul>
</li>
<li>简单的方式是将String转成NSString来使用<ul>
<li>在标识符后加:as NSString即可</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myStr = &quot;www.520it.com&quot;</span><br><span class="line">var subStr = (myStr as NSString).substringFromIndex(4)</span><br><span class="line">subStr = (myStr as NSString).substringToIndex(3)</span><br><span class="line">subStr = (myStr as NSString).substringWithRange(NSRange(location: 4, length: 5))</span><br></pre></td></tr></table></figure>
<ul>
<li>swift截取方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义字符串</span><br><span class="line">let str = &quot;www.520it.com&quot;</span><br><span class="line"></span><br><span class="line">// 2.截取开始位置</span><br><span class="line">let fromIndex = str.startIndex.advancedBy(3)</span><br><span class="line">let header = str.substringFromIndex(fromIndex)</span><br><span class="line"></span><br><span class="line">// 3.截取结束位置</span><br><span class="line">let toIndex = str.endIndex.advancedBy(-3)</span><br><span class="line">let footer = str.substringToIndex(toIndex)</span><br><span class="line"></span><br><span class="line">// 4.截取中间的字符串</span><br><span class="line">let range = Range(start: str.startIndex.advancedBy(4), end: str.endIndex.advancedBy(-4))</span><br><span class="line">let middle = str.substringWithRange(range)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>tableView的性能优化</title>
    <url>/2016/06/02/tableView%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="tableView性能优化"><a href="#tableView性能优化" class="headerlink" title="tableView性能优化"></a>tableView性能优化</h3><p>tableview的优化一直是一个很考验基本功的活儿，之前做项目的适合被这个问题困扰了很久，通过性能工具、查阅文档解决，整理思路和解决方案如下：</p>
<h4 id="tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。"><a href="#tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。" class="headerlink" title="tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。"></a>tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。</h4><ul>
<li>cell是否使用了复用机制而不是每一次都创建新的cell。</li>
</ul>
<p>如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。<br><span id="more"></span></p>
<ul>
<li>cell是否添加了大量的子控件，或者对layer做了过多的操作。</li>
</ul>
<p>如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。</p>
<ul>
<li>高度计算方法时不做复杂的计算，尽量只使用加减乘除。</li>
</ul>
<p>自适应高度的cell实现方式有很多种，比如，</p>
<p>1.使用iOS7以上系统的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat</span><br></pre></td></tr></table></figure>
<p>这个方法中，可以先给一个估计的高度，系统会从你给定的高度再去计算实际高度。但是在使用过程中会出现cell突然变高变得低的情况，不适用于高度变化太大的cell。</p>
<p>2.如果使用约束布局创建的cell子控件，子控件之间都建立了相互约束，最上面的子控件与cell顶部建立约束，最下面的子控件与cell底部建立了约束，相当于子控件把cell撑开了。</p>
<p>约束简图:<br><img src="/Users/nick/Desktop/1.jpeg" alt=""></p>
<p>这时在高度计算方法中，走一遍cell的loaddata方法后可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func systemLayoutSizeFittingSize(targetSize: CGSize) -&gt; CGSize</span><br></pre></td></tr></table></figure>
<p>取得cell的size，进而得到cell高度。<br>通过这个方法获取的cell高度是十分精确的，只要创建好子控件的约束就能获得cell的size。比较不好的是只是这种方法会重走一遍cell的loaddata方法。除此之外在调用cell的loaddata之前需要得到cell的实例，实例创建的方式应该与cellForRow方法一样，优先从缓存池中取得。<br>这个方案可能会创建多个cell。如果能在内存汇总保存一份cell的实例就能解决这个问题了！我讲讲我实现的思路：<br>首先先注册cell,当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回给你。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override func viewDidLodad() &#123;</span><br><span class="line">    tableView.registerClass(CardCell.self, forCellReuseIdentifier: ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用lazy创建一个cell实例，由于lazy 关键字，cell的创建只会执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazy var cell:CardCell = &#123;</span><br><span class="line">      //已经注册过cell，当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回</span><br><span class="line">      let v = self.myTableView?.dequeueReusableCellWithIdentifier(self.ID) as! CardCell</span><br><span class="line">      return v</span><br><span class="line">      &#125;()</span><br></pre></td></tr></table></figure>
<p>通过懒加载的方式，只创建一次cell的实例，避免内存浪费。<br>接下来要做的步骤就是之前讲的，调用cell的loadData方法，计算高度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</span><br><span class="line">  self.imageCell.loadData(d)    </span><br><span class="line">  let height:CGFloat = self.cell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize).height</span><br><span class="line">return height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="之前查资料的时候还有用空间换取时间的方案："><a href="#之前查资料的时候还有用空间换取时间的方案：" class="headerlink" title="之前查资料的时候还有用空间换取时间的方案："></a>之前查资料的时候还有用空间换取时间的方案：</h4><p>1）在请求网络数据成功后就计算好高度并通过字典或者数组保存高度值，在高度方法中直接根据数组下标或者key值取得高度并返回。</p>
<p>2）还有建立一个frameModel的方法，与1中相似，只是获得网络数据后保存到frameModel中，在frameModel中定义一个类方法，通过获得的model值计算高度后返回。<br>避免快速滑动情况下开过多线程。<br>cell中的图片开线程异步加载，相信每个人都会想到。线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">      var canLoad:Bool = !tableView.dragging &amp;&amp; !tableView.declearating</span><br><span class="line">      if  canLoad &#123;</span><br><span class="line">          //开始loaddata，异步加载图片</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图片处理</li>
</ul>
<p>1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。<br>2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示<br>3）避免对layer做过多的操作，尽量设置图片为不透明</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><ul>
<li>简单的设置cornerRadius是不会影响性能的，但是设置了maskToBounds，会导致离屏渲染，应减少设置图层 maskToBounds = YES ，；</li>
<li>使用懒加载图片的方式避免重复下载图片，浪费资源。图片下载后并做压缩处理后将其保存到缓存中，下次加载此图片之前先从缓存中取，如果取不到该图片就在后台下载保存。</li>
<li>使用Core Graphics实现圆角等功能。</li>
<li>重写drawRect方法会离屏渲染，导致内存急剧上升，即使在这个方法里面不写一句代码，也会让内存升高。</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>原生集成code-push热更新RN功能</title>
    <url>/2019/08/16/%E5%8E%9F%E7%94%9F%E9%9B%86%E6%88%90codePush%E7%83%AD%E6%9B%B4%E6%96%B0RN%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>code-push是一个微软开发的云服务器。通过它，开发者可以直接在用户的设备上部署手机应用更新。code-push相当于一个中心仓库，开发者可以推送当前的更新（包括JS/HTML/CSS/IMAGE等）到code-push，然后应用将会查询是否有更新。<br>虽然苹果禁了很多热更新，但是，code-push 还是可以用的。项目是 ReactNative 的，总结了下 iOS 的 code-push 的使用方法。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/6a5e00d22723">code-push热更新详细接入教程</a><br><a href="https://www.jianshu.com/p/6bbb8020c29e">code-push热更新配置（命令整理）</a><br><span id="more"></span></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="安装code-push-cli"><a href="#安装code-push-cli" class="headerlink" title="安装code-push-cli"></a>安装code-push-cli</h4><p>安装code-push指令，直接在终端上输入如下命令即可，注意：这个code-push指令只需要全局安装一次即可，如果第一次安装成功了，那后面就不在需要安装<br><code>npm install -g code-push-cli</code></p>
<h4 id="注册code-push账号"><a href="#注册code-push账号" class="headerlink" title="注册code-push账号"></a>注册code-push账号</h4><ul>
<li>注册code-push账号也很简单，同样是只需简单的执行下面的命令，同样这个注册操作也是全局只需要注册一次即可<code>code-push register</code></li>
<li>当执行完上面的命令后，会自动打开一个授权网页，让你选择使用哪种方式进行授权登录，这里我们统一就选择使用GitHub即可</li>
<li>当注册成功后，code-push会给我们一个key</li>
<li>我们直接复制这个key，然后在终端中将这个key填写进去即可</li>
<li>验证是否登录成功 <code>code-push login</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code-push注册登录相关命令：</span><br><span class="line">	•	code-push login 登陆</span><br><span class="line">	•	code-push loout 注销</span><br><span class="line">	•	code-push access-key ls 列出登陆的token</span><br><span class="line">	•	code-push access-key rm &lt;accessKye&gt; 删除某个 access-key</span><br></pre></td></tr></table></figure>
<h4 id="在code-push服务器注册App"><a href="#在code-push服务器注册App" class="headerlink" title="在code-push服务器注册App"></a>在code-push服务器注册App</h4><p><code>code-push app add 项目名称 ios react-native</code><br>可以查看添加的App列表<br><code>code-push app list</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code-push管理App的相关命令：</span><br><span class="line">	•	code-push app add 在账号里面添加一个新的app</span><br><span class="line">	•	code-push app remove 或者 rm 在账号里移除一个app</span><br><span class="line">	•	code-push app rename 重命名一个存在app</span><br><span class="line">	•	code-push app list 或则 ls 列出账号下面的所有app</span><br><span class="line">	•	code-push app transfer 把app的所有权转移到另外一个账号</span><br></pre></td></tr></table></figure>
<h4 id="RN代码中集成code-push-不熟悉先省略"><a href="#RN代码中集成code-push-不熟悉先省略" class="headerlink" title="RN代码中集成code-push (不熟悉先省略)"></a>RN代码中集成code-push (不熟悉先省略)</h4><h4 id="原生应用中配置code-push"><a href="#原生应用中配置code-push" class="headerlink" title="原生应用中配置code-push"></a>原生应用中配置code-push</h4><ul>
<li>使用Xcode打开项目，Xcode的项目导航视图中的PROJECT下选择你的项目，选择Info页签 ，在Configurations节点下单击 + 按钮 ，选择Duplicate “Release Configaration，输入Staging</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-fbfc9b79199d4a3f..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<ul>
<li>选择Build Settings tab，搜索Build Location -&gt; Per-configuration Build Products Path -&gt; Staging，将之前的值：<code>$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)</code> 改为：<code>$(BUILD_DIR)/Release$(EFFECTIVE_PLATFORM_NAME)</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-369c31244b0f528f..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<ul>
<li>选择Build Settings tab，点击 + 号，选择Add User-Defined Setting，将key设置为<code>CODEPUSH_KEY</code>，Release 和 Staging的值为前面创建的key，我们直接复制进去即可</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-663dc2df47438cc5..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<ul>
<li>•    打开Info.plist文件，在<code>CodePushDeploymentKey</code>中输入<code>$(CODEPUSH_KEY)</code>，并修改<code>Bundle versions string,short</code>为三位</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-c4392091edc647a0..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<h4 id="打包RN离线的jsbundle"><a href="#打包RN离线的jsbundle" class="headerlink" title="打包RN离线的jsbundle"></a>打包RN离线的jsbundle</h4><ol>
<li><p>在package.json根目录创建文件夹relseae_ios， 执行如下命令打包成index.bundle<br><code>react-native bundle --entry-file index.js --platform ios --dev false --bundle-output relseae_ios/index.bundle --assets-dest relseae_ios</code></p>
</li>
<li><p>将index.bundle拷贝到当前目录<br><code>cp ./relseae_ios/index.bundle ./</code></p>
</li>
<li><p>开启本地服务，生成jsbundle<br>在根目录执行npm start<br>Ctrl+T 开启新窗口（确保在pakage.json根目录）<br>执行命令  <code>curl &#39;http://localhost:8081/index.bundle?dev=false&amp;minify=true&amp;platform=ios&#39; -o main.jsbundle</code></p>
</li>
<li><p>将main.jsbundle复制到relseae_ios目录下<br><code>cp ./main.jsbundle ./relseae_ios</code></p>
</li>
<li><p>将根目录里的<code>main.jsbundle</code>和<code>relseae_ios目录下的资源文件</code>拖拽至工程下 </p>
</li>
<li><p>设置Bundle离线包路径<br><code>jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</code></p>
</li>
</ol>
<h4 id="发布RN更新jsbundle版本"><a href="#发布RN更新jsbundle版本" class="headerlink" title="发布RN更新jsbundle版本"></a>发布RN更新jsbundle版本</h4><ul>
<li><p>原生AppDelegete里需要配置<br><code>jsCodeLocation = [CodePush bundleURL];</code></p>
</li>
<li><p>更新jsbundle 要用以下命令 在项目根目录里<br><code>code-push release TheOnlineTax ./relseae_ios/ 3.5.5 --des &quot;还原RN代码” --m true —-d Production</code></p>
</li>
</ul>
<p><strong>注：</strong><br>强制更新 –m true<br>生产环境 –d Production </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名称    TheOnlineTax    </span><br><span class="line">文件路径    ./relseae_ios/  </span><br><span class="line">项目版本号  3.5.5           </span><br><span class="line">更新描述    &quot;还原RN代码”     </span><br></pre></td></tr></table></figure>
<ul>
<li>查看更新情况</li>
</ul>
<p>生成环境 <code>code-push deployment history 项目名称 Production</code><br>开发环境 <code>code-push deployment history 项目名称 Staging</code><br>或者 <code>code-push deployment ls 项目名称</code></p>
]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>热更新</tag>
      </tags>
  </entry>
  <entry>
    <title>发布过程的问题</title>
    <url>/2017/01/23/%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="发布时遇到的一些问题"><a href="#发布时遇到的一些问题" class="headerlink" title="发布时遇到的一些问题"></a>发布时遇到的一些问题</h3><h4 id="iOS10-之后需要添加info-plist文件配置"><a href="#iOS10-之后需要添加info-plist文件配置" class="headerlink" title="iOS10 之后需要添加info.plist文件配置:"></a>iOS10 之后需要添加info.plist文件配置:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开蓝牙可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开相机可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开通讯录可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开麦克风可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开相册可以吗？&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>若没有apple会发此邮箱:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This app attempts to access privacy-sensitive data without a usage description. The app&#x27;s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.</span><br><span class="line"></span><br><span class="line">This app attempts to access privacy-sensitive data without a usage description. The app&#x27;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.</span><br></pre></td></tr></table></figure></p>
<h4 id="报错"><a href="#报错" class="headerlink" title="报错:"></a>报错:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- ERROR ITMS-90474: &quot;Invalid Bundle. iPad Multitasking support requires these orientations: &#x27;UIInterfaceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown,UIInterfaceOrientationLandscapeLeft,UIInterfaceOrientationLandscapeRight&#x27;. Found &#x27;UIInterfaceOrientationPortrait&#x27; in bundle &#x27;xxxx&#x27;.&quot; </span><br><span class="line">- ERROR ITMS-90475: &quot;Invalid Bundle. iPad Multitasking support requires launch story board in bundle &#x27;xxxx’.&quot; </span><br></pre></td></tr></table></figure>
<p>解决方案:<br>打开项目属性，选择“General”选项，勾选红框标注的“Requires full screen”</p>
<h4 id="报错-1"><a href="#报错-1" class="headerlink" title="报错:"></a>报错:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR ITMS-90032:“Invalid Image Path - No image found at the path referenced under key &#x27;CFBundleIcons&#x27;:AppIcon40x40”</span><br></pre></td></tr></table></figure>
<p>解决方案:<br>图片的问题  缺少对应的图片尺寸 需要在图片资源文件的 appicon中添加</p>
<p><img src="/Users/nick/Desktop/Snip20170122_3.png" alt=""></p>
]]></content>
      <categories>
        <category>发布问题</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>siwft笔记3</title>
    <url>/2016/01/27/siwft%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="一-三大特性"><a href="#一-三大特性" class="headerlink" title="一.三大特性"></a>一.三大特性</h3><ul>
<li>封装</li>
<li>继承<ul>
<li>重写父类方法 需要加上 override</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li>必须要有继承</li>
<li>必须要有重写</li>
<li>必须是父类指针指向子类对象</li>
</ul>
</li>
<li>(重载)<ul>
<li>参数类型不同</li>
<li>参数个数不同</li>
</ul>
</li>
</ul>
<h3 id="二-自动引用计数"><a href="#二-自动引用计数" class="headerlink" title="二.自动引用计数"></a>二.自动引用计数</h3><ul>
<li>当有一个强引用指向某个对象时,该对象的引用计数会自动 + 1</li>
<li>当强引用消失时,引用计数会自动 - 1</li>
<li><p>当引用计数为0时,该对象会被销毁</p>
<span id="more"></span>
<h5 id="循环引用-的解决"><a href="#循环引用-的解决" class="headerlink" title="循环引用 的解决"></a>循环引用 的解决</h5><pre><code>1.weak       和OC中的 __weak一样 是弱引用  当指向的对象销毁时,会自动指向nil
2.unowned    和OC中的 __unsefe_unretained   当对象销毁时依然指向原来的位置(容易引起野指针)
</code></pre></li>
</ul>
<h3 id="三-可选链"><a href="#三-可选链" class="headerlink" title="三.可选链"></a>三.可选链</h3><ul>
<li>如果可选的目标有值,就调用成功</li>
<li>如果没有值,则调用返回空nil  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   // OC对象结构体的成员属性不能直接赋值</span><br><span class="line">   titleLabel?.frame.origin.x = 0</span><br></pre></td></tr></table></figure>
<h3 id="四-协议-protocol"><a href="#四-协议-protocol" class="headerlink" title="四.协议  protocol"></a>四.协议  protocol</h3><ul>
<li><h5 id="定义协议和遵守协议"><a href="#定义协议和遵守协议" class="headerlink" title="定义协议和遵守协议"></a>定义协议和遵守协议</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义协议</span><br><span class="line">protocol SportProtocol &#123; </span><br><span class="line">     func playBasketball() </span><br><span class="line">     func playFootball()</span><br><span class="line">&#125;</span><br><span class="line">// 2.遵守协议</span><br><span class="line">// 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错</span><br><span class="line">class Person : SportProtocol &#123; </span><br><span class="line">     var name : String? var age : Int = 0</span><br><span class="line">   // 实现协议中的方法 </span><br><span class="line">     func playBasketball() &#123; </span><br><span class="line">         print(&quot;人在打篮球&quot;) </span><br><span class="line">     &#125;</span><br><span class="line">     func playFootball() &#123; </span><br><span class="line">         print(&quot;人在踢足球&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="协议之间的继承"><a href="#协议之间的继承" class="headerlink" title="协议之间的继承"></a>协议之间的继承</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol CrazySportProtocol &#123;      </span><br><span class="line">      func jumping()</span><br><span class="line">&#125;</span><br><span class="line">protocol SportProtocol : CrazySportProtocol &#123;</span><br><span class="line">     func playBasketball()   </span><br><span class="line">     func playFootball()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="协议中方法的可选-需加-objc-和-optional-关键字"><a href="#协议中方法的可选-需加-objc-和-optional-关键字" class="headerlink" title="协议中方法的可选  需加 @objc 和 optional 关键字"></a>协议中方法的可选  需加 @objc 和 optional 关键字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义协议</span><br><span class="line">@objc</span><br><span class="line">protocol SportProtocol &#123;</span><br><span class="line">    func playBasketball()</span><br><span class="line">    optional func playFootball()</span><br><span class="line">&#125;</span><br><span class="line">// 2.遵守协议</span><br><span class="line">class Person : SportProtocol &#123;</span><br><span class="line">    var name : String?</span><br><span class="line">    var age : Int = 0</span><br><span class="line">    // 实现协议中的方法</span><br><span class="line">    @objc func playBasketball() &#123;</span><br><span class="line">        print(&quot;人在打篮球&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义协议属性 用 weak 且协议后面需 : class 才不会报错</span><br><span class="line">protocol BuyTicketProtocol : class &#123;</span><br><span class="line">    func buyTicket()&#125;class Person &#123;    // 1.定义协议属性</span><br><span class="line">    weak var delegate : BuyTicketProtocol</span><br><span class="line">    func goToHeFei()&#123;</span><br><span class="line">        delegate?.buyTicketing()</span><br><span class="line">        print(&quot;去北京&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;class Huangniu: BuyTicketDelegate &#123;</span><br><span class="line">    func buyTicketing() &#123;</span><br><span class="line">        print(&quot;买票&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理对象</span><br><span class="line">//设置代理时 没有self   需要先 let 创建代理对象  然后再 设置代理 = 代理对象</span><br><span class="line">let h = Huangniu()</span><br><span class="line">let p = Person()</span><br><span class="line">p.delegate = h</span><br><span class="line">p.goToHeFei()    </span><br></pre></td></tr></table></figure>
<h3 id="五-闭包-类似OC中的Block"><a href="#五-闭包-类似OC中的Block" class="headerlink" title="五.闭包 (类似OC中的Block)"></a>五.闭包 (类似OC中的Block)</h3><ul>
<li>block的写法:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    类型:    返回值(^block的名称)(block的参数)</span><br><span class="line">    值:</span><br><span class="line">    ^(参数列表) &#123;</span><br><span class="line">        // 执行的代码</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的写法:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    类型:(形参列表)-&gt;(返回值)</span><br><span class="line">    技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值</span><br><span class="line">    值:</span><br><span class="line">    &#123;</span><br><span class="line">        (形参) -&gt; 返回值类型 in</span><br><span class="line">        // 执行代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的循环引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> 需要用到self的地方:</span><br><span class="line">     1.如果某一个方法中,有局部变量和成员变量产生歧义,可以使用self进行区分</span><br><span class="line">     2.如果在闭包中使用到当前对象的方法或者属性,都需要加self</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 解决方案一:</span><br><span class="line">        weak var weakself : ViewController? = self</span><br><span class="line">        httpTool?.loadData(&#123; (jsonData) -&gt; () in</span><br><span class="line">        weakself?.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;)</span><br><span class="line">// 解决方案二:(推荐)</span><br><span class="line">        httpTool?.loadData(&#123;[weak self] (jsonData) -&gt; () in            self?.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="六-懒加载"><a href="#六-懒加载" class="headerlink" title="六.懒加载"></a>六.懒加载</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazy var 变量: 类型 = &#123; 创建变量代码 &#125;()</span><br></pre></td></tr></table></figure>
<ul>
<li>懒加载的使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 懒加载的本质是,在第一次使用的时候执行闭包,将闭包的返回值赋值给属性</span><br><span class="line">// lazy的作用是只会赋值一次</span><br><span class="line">    lazy var array : [String] = &#123;</span><br><span class="line">        return [&quot;why&quot;, &quot;lmj&quot;, &quot;lnj&quot;]</span><br><span class="line">    &#125;()</span><br><span class="line">     lazy var btn : UIButton = &#123;</span><br><span class="line">        let tempBtn = UIButton()</span><br><span class="line">        tempBtn.setTitle(&quot;按钮&quot;, forState: .Normal)</span><br><span class="line">        return tempBtn</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>
<h3 id="七-常见注释"><a href="#七-常见注释" class="headerlink" title="七.常见注释"></a>七.常见注释</h3><ul>
<li>单行注释 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注释内容</span><br></pre></td></tr></table></figure>
<ul>
<li>多行注释 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">(与OC不同  可以多行嵌套多行注释) </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注释内容</span><br></pre></td></tr></table></figure>
<ul>
<li>分组注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MARK:-</span><br></pre></td></tr></table></figure>
<h3 id="八-访问权限"><a href="#八-访问权限" class="headerlink" title="八.访问权限"></a>八.访问权限</h3><ul>
<li>Swift 中的访问控制模型基于模块和源文件这两个概念</li>
<li>private : 修饰源文件,在当前源文件中可以访问</li>
<li>internal : 内部的,修饰整个项目,在整个项目中都可以进行访问,并且默认修饰的就是internal</li>
<li>public :  修饰整个项目,可以跨框架使用<br>(在class 和 func前面加)</li>
</ul>
<h3 id="九-处理异常-三种方式"><a href="#九-处理异常-三种方式" class="headerlink" title="九.处理异常  (三种方式)"></a>九.处理异常  (三种方式)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 3.异常的处理三种方式</span><br><span class="line">// 3.1.try方式,需要手动处理异常do &#123;</span><br><span class="line">    let result = try readFileContent(&quot;abc&quot;)&#125; catch &#123;</span><br><span class="line">    print(error)&#125;</span><br><span class="line">// 3.2.try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值</span><br><span class="line">// 最终返回结果为一个可选类型let result = try? readFileContent(&quot;abc&quot;)</span><br><span class="line">// 3.3.try!方法,告诉系统该方法没有异常.</span><br><span class="line">// 注意:如果出现了异常,则程序会崩溃</span><br><span class="line">    let result = try! readFileContent(&quot;abc&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">// 1.定义异常enum FileReadError : ErrorType &#123;</span><br><span class="line">    case FileISNull</span><br><span class="line">    case FileNotFound</span><br><span class="line">&#125;</span><br><span class="line">// 2.改进方法,让方法抛出异常</span><br><span class="line">func readFileContent(filePath : String) throws -&gt; String &#123;</span><br><span class="line">    // 1.filePath为&quot;&quot;</span><br><span class="line">    if filePath == &quot;&quot; &#123;</span><br><span class="line">        throw FileReadError.FileISNull</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.filepath有值,但是没有对应的文件  </span><br><span class="line">    if filePath != &quot;/User/Desktop/123.plist&quot; &#123;        throw FileReadError.FileISNull    &#125;    // 3.取出其中的内容    return &quot;123&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十-桥接"><a href="#十-桥接" class="headerlink" title="十.桥接"></a>十.桥接</h3><ul>
<li>OC调用swift</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.直接写入一个头文件:  项目名字-Swift.h      </span><br><span class="line">#import &quot;项目名字-Swift.h&quot;</span><br><span class="line"></span><br><span class="line">2.在swift中 添加public关键字 在class和func前面</span><br><span class="line"> (还是以OC格式书写)</span><br></pre></td></tr></table></figure>
<ul>
<li>swift调用OC</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.建立桥接文件  Bridge.h  里面放 .h头文件</span><br><span class="line">2.在项目中Build Settings 配置文件  搜索bird  </span><br><span class="line">然后将Bridge.h路径存入(类似PCH文件)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>私有项目或功能集成到SVN 通过pod下载</title>
    <url>/2019/07/16/%E7%A7%81%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%88%96%E5%8A%9F%E8%83%BD%E9%9B%86%E6%88%90%E5%88%B0SVN-%E9%80%9A%E8%BF%87pod%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.jianshu.com/p/cbb8931499da">结合cocoapods谈iOS私有库的三种管理方式</a><br><a href="https://www.jianshu.com/p/217841b3eb7d">利用公司SVN服务器 使用cocoaPods管理自己的私有库</a></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><strong>注：</strong> 需要安装repo-svn插件 <code>gem install cocoapods-repo-svn</code> （PS：会报权限问题，出现的Error可以忽略，改成<code>sudo gem install cocoapods-repo-svn</code>）</p>
<span id="more"></span>
<ul>
<li>创建podspec文件   <code>pod spec create 文件名</code></li>
<li>将项目或功能上传至SVN<ul>
<li>有(branches、tags、trunk)三个目录 一般放到truck或者branches里 </li>
<li>通过打标签设置版本号 (先在tags里创建该文件空的，然后选择tag选择到该文件下打版本标签) </li>
</ul>
</li>
<li><code>pod repo-svn add tags  svn上tags的地址</code> （添加项目）   可在 <code>~/.cocoapods/repos/</code> 查看</li>
<li><code>pod repo-svn update tags</code> （更新项目）</li>
<li>可在podfile文件中添加 （tags在svn上的地址）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugin &#x27;cocoapods-repo-svn&#x27;, :sources =&gt; [</span><br><span class="line">   中括号内的 为tags在SVN上的地址、也是podspec里source地址加上/tags</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>直接 <code>pod ‘名称’, ‘版本号’</code></li>
<li><code>pod install</code> 即可 </li>
<li>若有修改SVN中的文件 需要先 删除pod缓存 <code>open ~/Library/Caches/Cocoapods</code> 再<code>pod install</code></li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>可通过 <code>pod spec lint TrackAction.podspec --verbose --use-libraries --allow-warnings</code> 检查错误 </p>
</li>
<li><p>集成到GitHub 通过pod管理  原理类似  可在简书 <a href="https://www.jianshu.com/bookmarks">收藏的文章</a> 中查找 </p>
</li>
<li><p>cocoapods缓存问题  解决修改了tags里内容但pod下来却没有更新<br> 删除pod  <code>~/Library/Caches/Cocoapods</code><br> <a href="https://www.jianshu.com/p/f936794aa512">https://www.jianshu.com/p/f936794aa512</a>  </p>
</li>
<li><p>需要注意的地方 在项目中写在pch的头文件 若要集成出来  需要在对应的文件里写上这个头文件 不然会报错找不到 </p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SVN</tag>
        <tag>cocoapods</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>学习数据建模</title>
    <url>/2020/02/13/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2020年年关，“新冠状病毒”感染所致的肺炎肆虐全国，成为了继2003年非典以来更严重的瘟疫。口罩是预防肺炎的有效手段之一，口罩的种类有多种，比如纱布口罩、医用口罩（如N95）、日用口罩、防尘口罩等，口罩的制作过程、工艺、样式大致相同，但使用对象会因为不同的使用场景而不同，比如普通民众和医生使用的口罩，室内生产线上的工人和场外工地上的工人使用的口罩。<br>口罩当前已成为了“硬通货”，堪比日常的油盐酱醋，全国各地都在加班加点生产，近日，富士康和比亚迪已宣布开始生产口罩。<br>请根据以上材料结合设计模式的相关知识对口罩进行建模？</p>
<span id="more"></span>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://blog.csdn.net/zhangchen2449/article/details/80530027">商品销售数据建模及分析</a><br><a href="https://blog.csdn.net/gao2175/article/details/90206739">3个问题带你入门数据建模</a><br><a href="https://www.iteye.com/blog/student-lp-2212743">数据仓库建设-数据建模</a><br><a href="http://www.itxm.cn/post/6976.html">数据建模详解</a></p>
<h3 id="模块目录"><a href="#模块目录" class="headerlink" title="模块目录"></a>模块目录</h3><ul>
<li><p><a href="#module-MASK-relation" title="关联关系"><h5 id="module-MASK-relation}-from">1. 关联关系</h5></a></p>
</li>
<li><p><a href="#module-MASK-tableList" title="表清单"><h5 id="module-MASK-tableList-from">2. 表清单</h5></a></p>
</li>
<li><p><a href="#module-MASK-tableColumnList" title="表列清单"><h5 id="module-MASK-tableColumnList-from">3. 表列清单</h5></a></p>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_KIND" title="MASK_KIND"><h6 id="module-MASK-tableColumnList-MASK_KIND-from">3.1 MASK_KIND【种类】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_STANDARD" title="MASK_STANDARD"><h6 id="module-MASK-tableColumnList-MASK_STANDARD-from">3.2 MASK_STANDARD【执行标准】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_FUNCTION" title="MASK_FUNCTION"><h6 id="module-MASK-tableColumnList-MASK_FUNCTION-from">3.3 MASK_FUNCTION【功能】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_COMPOSITIONS" title="MASK_COMPOSITIONS"><h6 id="module-MASK-tableColumnList-MASK_COMPOSITIONS-from">3.4 MASK_COMPOSITIONS【产品构成】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_USER" title="MASK_USER"><h6 id="module-MASK-tableColumnList-MASK_USER-from">3.5 MASK_USER【使用对象】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_RANGE" title="MASK_RANGE"><h6 id="module-MASK-tableColumnList-MASK_RANGE-from">3.6 MASK_RANGE【适用场景】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_RISK" title="MASK_RISK"><h6 id="module-MASK-tableColumnList-MASK_RISK-from">3.7 MASK_RISK【风险等级】</h6></a></li>
</ul>
<hr>
</li>
</ul>
<p><a href="#module-MASK-relation-from"><h5 id="module-MASK-relation">1.关联关系</h5></a></p>
<hr>
<p><img src="/images/口罩数据建模.png" alt="MASK-关系图"></p>
<hr>
<p> <a href="#module-MASK-tableList-from"><h5 id="module-MASK-tableList">2.表清单</h5></a></p>
<hr>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>种类</td>
<td>MASK_KIND</td>
<td></td>
</tr>
<tr>
<td>执行标准</td>
<td>MASK_STANDARD</td>
<td></td>
</tr>
<tr>
<td>功能</td>
<td>MASK_FUNCTION</td>
<td></td>
</tr>
<tr>
<td>产品构成</td>
<td>MASK_COMPOSITIONS</td>
<td></td>
</tr>
<tr>
<td>使用对象</td>
<td>MASK_USER</td>
<td></td>
</tr>
<tr>
<td>适用场景</td>
<td>MASK_RANGE</td>
<td></td>
</tr>
<tr>
<td>风险等级</td>
<td>MASK_RISK</td>
</tr>
</tbody>
</table>
<hr>
<p> <a href="#module-MASK-tableColumnList-from"><h5 id="module-MASK-tableColumnList">3.表列清单</h5></a></p>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_KIND-from"><h6 id="module-MASK-tableColumnList-MASK_KIND">MASK_KIND【种类】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>种类ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>种类名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IMAGE</td>
<td>种类图片</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PIRCE</td>
<td>价格</td>
<td>DECIMAL(32,8)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>STANDARD_ID</td>
<td>所属执行标准</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CONMPOSITIONS_ID</td>
<td>所属组成成分</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FUNCTION_ID</td>
<td>所属功能</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RANGE_ID</td>
<td>适用场景</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DIMENSIONS</td>
<td>尺寸规格</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VENDORS</td>
<td>生产厂商</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_STANDARD-from"><h6 id="module-MASK-tableColumnList-MASK_STANDARD">MASK_STANDARD【执行标准】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>标准ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>标准名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LEVEL</td>
<td>防护等级</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_FUNCTION-from"><h6 id="module-MASK-tableColumnList-MASK_FUNCTION">MASK_FUNCTION【功能】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>功能ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>FUNCTIONS</td>
<td>功能项</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NOTICE</td>
<td>注意项</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CYCLE</td>
<td>使用周期</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>THEORY</td>
<td>工作原理</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_COMPOSITIONS-from"><h6 id="module-MASK-tableColumnList-MASK_COMPOSITIONS">MASK_COMPOSITIONS【产品构成】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>组成成分ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>GATHER</td>
<td>构成</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FORM</td>
<td>形式</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RESERVE</td>
<td>储存条件</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BATCHNUM</td>
<td>生产批号</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PRODUCTDATE</td>
<td>生产日期</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VALIDITY</td>
<td>有效期</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ENTERPRISE</td>
<td>生产企业</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ADDRESS</td>
<td>生产地址</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_USER-from"><h6 id="module-MASK-tableColumnList-MASK_USER">MASK_USER【使用对象】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>对象ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>对象名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>KIND_ID</td>
<td>种类ID</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GENDER</td>
<td>性别</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AGE</td>
<td>年龄</td>
<td>INT</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PROFESSION</td>
<td>职业</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CHANNEL</td>
<td>购买渠道</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RISK_ID</td>
<td>风险等级</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UNSUITABLE_USER</td>
<td>不适人群</td>
<td>VARCHAR(512)</td>
<td></td>
<td>心脏或呼吸系统有困难的人（如哮喘肺气肿）、怀孕、佩戴后头晕、呼吸困难和皮肤敏感。</td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_RANGE-from"><h6 id="module-MASK-tableColumnList-MASK_RANGE">MASK_RANGE【适用场景】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>场景ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>场景名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RISK_ID</td>
<td>风险等级</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_RISK-from"><h6 id="module-MASK-tableColumnList-MASK_RISK">MASK_RISK【风险等级】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>风险ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>等级名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>EXPLAIN</td>
<td>风险说明</td>
<td>VARCHAR(512)</td>
<td></td>
<td>高、较高、中、较低、低等级 判定</td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <tags>
        <tag>数据建模</tag>
        <tag>PDMan</tag>
      </tags>
  </entry>
  <entry>
    <title>数据安全</title>
    <url>/2016/04/05/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="1-Base64"><a href="#1-Base64" class="headerlink" title="1.Base64"></a>1.Base64</h3><h4 id="1-Base64简单说明"><a href="#1-Base64简单说明" class="headerlink" title="1.Base64简单说明"></a>1.Base64简单说明</h4><pre><code>描述：Base64可以成为密码学的基石，非常重要。
特点：可以将任意的二进制数据进行Base64编码
结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。
65字符：A~Z a~z 0~9 + / =
对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。
</code></pre><h4 id="2-命令行进行Base64编码和解码"><a href="#2-命令行进行Base64编码和解码" class="headerlink" title="2.命令行进行Base64编码和解码"></a>2.命令行进行Base64编码和解码</h4><pre><code>编码：base64 123.png -o 123.txt
解码：base64 123.txt -o test.png -D
</code></pre><span id="more"></span>
<h4 id="3-Base64编码原理"><a href="#3-Base64编码原理" class="headerlink" title="3.Base64编码原理"></a>3.Base64编码原理</h4><pre><code>1)将所有字符转化为ASCII码；
2)将ASCII码转化为8位二进制；
3)将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；
4)统一在6位二进制前补两个0凑足8位；
5)将补0后的二进制转为十进制；
6)从Base64编码表获取十进制对应的Base64编码；
</code></pre><p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。<br>    b.数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加1个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加2个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</p>
<h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h4><pre><code>a.说明：
    1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持
    2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。

b.相关代码：
//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果
-(NSString *)base64EncodeString:(NSString *)string
&#123;
    //1.先把字符串转换为二进制数据
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];

    //2.对二进制数据进行base64编码，返回编码后的字符串
    return [data base64EncodedStringWithOptions:0];
&#125;

//对base64编码后的字符串进行解码
-(NSString *)base64DecodeString:(NSString *)string
&#123;
    //1.将base64编码后的字符串『解码』为二进制数据
    NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0];

    //2.把二进制数据转换为字符串返回
    return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
&#125;

c.终端测试命令
    $ echo -n A | base64
    $ echo -n QQ== |base64 -D
</code></pre><h3 id="2-常见的加密算法和其它"><a href="#2-常见的加密算法和其它" class="headerlink" title="2.常见的加密算法和其它"></a>2.常见的加密算法和其它</h3><ul>
<li>base64 编码格式</li>
<li>密码学演化 “秘密本”–&gt;RSA</li>
<li>常见的加密算法<ul>
<li>消息摘要（单向散列函数）</li>
<li>对称加密</li>
<li>非对称加密</li>
<li>证书等</li>
</ul>
</li>
</ul>
<h3 id="3-单向散列函数"><a href="#3-单向散列函数" class="headerlink" title="3.单向散列函数"></a>3.单向散列函数</h3><h4 id="1-单向散列函数的特点："><a href="#1-单向散列函数的特点：" class="headerlink" title="1.单向散列函数的特点："></a>1.单向散列函数的特点：</h4><pre><code>①加密后密文的长度是定长的
②如果明文不一样，那么散列后的结果一定不一样
③如果明文一样，那么加密后的密文一定一样（对相同数据加密，加密后的密文一样）
④所有的加密算法是公开的
⑤不可以逆推反算
</code></pre><h4 id="2-经典加密算法"><a href="#2-经典加密算法" class="headerlink" title="2.经典加密算法"></a>2.经典加密算法</h4><pre><code>1）MD5加密
2）SHA1
3）SHA512
</code></pre><h4 id="3-MD5加密算法简单说明"><a href="#3-MD5加密算法简单说明" class="headerlink" title="3.MD5加密算法简单说明"></a>3.MD5加密算法简单说明</h4><pre><code>1）对字符串进行MD5加密可以得到一个32个字符的密文
2）加密之后不能根据密文逆推出明文
3）MD5已经被破解（暴力破解|碰撞检测）
</code></pre><h4 id="4-MD5加密进阶"><a href="#4-MD5加密进阶" class="headerlink" title="4.MD5加密进阶"></a>4.MD5加密进阶</h4><pre><code>1）先加盐，然后再进行MD5
2）先乱序，再进行MD5加密
3）乱序|加盐，多次MD5加密等
4）使用消息认证机制，即HMAC-MD5-先对密钥进行加密，加密之后进行两次MD5散列
5）加密命令行
    MD5加密-字符串    $ echo -n &quot;520it&quot; |md5
    MD5加密-文件1     $ md5 abc.png
    SHA1加密：        $ echo -n &quot;520it&quot; |openssl sha -sha1
    SHA256            $ echo -n &quot;520it&quot; |openssl sha -sha256
    SHA512            $ echo -n &quot;520it&quot; |openssl sha -sha512
    hmacMD5加密       $ echo -n &quot;520it&quot; |openssl dgst -md5 -hmac &quot;123&quot;
</code></pre><h4 id="5-散列函数应用领域"><a href="#5-散列函数应用领域" class="headerlink" title="5.散列函数应用领域"></a>5.散列函数应用领域</h4><pre><code>1）搜索 多个关键字，先对每个关键字进行散列，然后多个关键字进行或运算，如果值一致则搜索结果一致
2）版权 对文件进行散列判断该文件是否是正版或原版的
3）文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改
</code></pre><h4 id="6-消息认证机制（HMAC）简单说明"><a href="#6-消息认证机制（HMAC）简单说明" class="headerlink" title="6.消息认证机制（HMAC）简单说明"></a>6.消息认证机制（HMAC）简单说明</h4><pre><code>1）原理
    ①消息的发送者和接收者有一个共享密钥
    ②发送者使用共享密钥对消息加密计算得到MAC值（消息认证码）
    ③消息接收者使用共享密钥对消息加密计算得到MAC值
    ④比较两个MAC值是否一致
2）使用
    ①客户端需要在发送的时候把（消息）+（消息·HMAC）一起发送给服务器
    ②服务器接收到数据后，对拿到的消息用共享的KEY进行HMAC，比较是否一致，如果一致则信任
</code></pre><h3 id="4-对称加密"><a href="#4-对称加密" class="headerlink" title="4.对称加密"></a>4.对称加密</h3><h4 id="1-对称加密的特点"><a href="#1-对称加密的特点" class="headerlink" title="1.对称加密的特点"></a>1.对称加密的特点</h4><pre><code>1）加密/解密使用相同的密钥
2）加密和解密的过程是可逆的（明文-》明文-》明文）
</code></pre><h4 id="2-经典算法"><a href="#2-经典算法" class="headerlink" title="2.经典算法"></a>2.经典算法</h4><pre><code>1）DES 数据加密标准
2）3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密）
3）AES 高级加密标准
</code></pre><h4 id="3-分组密码简单说明"><a href="#3-分组密码简单说明" class="headerlink" title="3.分组密码简单说明"></a>3.分组密码简单说明</h4><pre><code>密码算法可以分为分组密码和流密码两种。
分组密码：每次只能处理特定长度的一zu数据的一类密码算法。一个分组的比特数量就称之为分组长度。
ex:DES和3DES的分组长度都是64比特。即每次只能加密64比特的明文，并生成64比特的密文。AES的分组长度有128比特、192比特和256比特可以选择。
流密码：对数据流进行连续处理的一类算法。流密码中一般以1比特、8比特或者是32比特等作为单位俩进行加密和解密。
</code></pre><h4 id="4-ECB分组模式"><a href="#4-ECB分组模式" class="headerlink" title="4.ECB分组模式"></a>4.ECB分组模式</h4><pre><code>ECB模式的全称为Electronic CodeBook模式。又成为电子密码本模式。
特点：
1）使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组。
2）类似于一个巨大的明文分组-》密文分组的对照表。
</code></pre><p><img src="/Users/nick/Desktop/1.png" alt=""></p>
<pre><code>终端测试命令：
加密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.txt -out 123.bin
解密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.bin -out 1231.txt -d
</code></pre><h4 id="5-CBC分组模式"><a href="#5-CBC分组模式" class="headerlink" title="5.CBC分组模式"></a>5.CBC分组模式</h4><pre><code>CBC模式全称为Cipher Block Chainning模式（密文分组链接模式|电子密码链条）
特点：在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。


终端命令：
加密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.txt -out a.bin
解密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.bin -out a1.txt -d
</code></pre><h3 id="5-非对称加密"><a href="#5-非对称加密" class="headerlink" title="5.非对称加密"></a>5.非对称加密</h3><h4 id="1-非对称加密的特点"><a href="#1-非对称加密的特点" class="headerlink" title="1.非对称加密的特点"></a>1.非对称加密的特点</h4><pre><code>1）使用公钥加密，使用私钥解密
2）公钥是公开的，私钥保密
3）加密处理安全，但是性能极差
</code></pre><p><img src="/Users/nick/Desktop/2.png" alt=""></p>
<h4 id="2-经典算法—RSA"><a href="#2-经典算法—RSA" class="headerlink" title="2.经典算法—RSA"></a>2.经典算法—RSA</h4><pre><code>1）RSA 原理
    （1）求N，准备两个质数p和q,N = p x q
    （2）求L,L是p-1和q-1的最小公倍数。L = lcm（p-1,q-1）
    （3）求E，E和L的最大公约数为1（E和L互质）
    （4）求D，E x D mode L = 1
2）RSA加密小实践
    （1）p = 17,q = 19 =&gt;N = 323
    （2）lcm（p-1,q-1）=&gt;lcm（16，18）=&gt;L= 144
    （3）gcd（E,L）=1 =&gt;E=5
    （4）E乘以几可以mode L =1? D=29可以满足
    （5）得到公钥为：E=5,N=323
    （6）得到私钥为：D=29,N=323
    （7）加密 明文的E次方 mod N = 123的5次方 mod 323 = 225（密文）
    （8）解密 密文的D次方 mod N = 225的29次方 mod 323 = 123（明文）
    ----------------
3）openssl生成密钥命令
    生成强度是 512 的 RSA 私钥：$ openssl genrsa -out private.pem 512
    以明文输出私钥内容：$ openssl rsa -in private.pem -text -out private.txt
    校验私钥文件：$ openssl rsa -in private.pem -check
    从私钥中提取公钥：$ openssl rsa -in private.pem -out public.pem -outform PEM -pubout
    以明文输出公钥内容：$ openssl rsa -in public.pem -out public.txt -pubin -pubout -text
    使用公钥加密小文件：$ openssl rsautl -encrypt -pubin -inkey public.pem -in msg.txt -out msg.bin
    使用私钥解密小文件：$ openssl rsautl -decrypt -inkey private.pem -in msg.bin -out a.txt
    将私钥转换成 DER 格式：$ openssl rsa -in private.pem -out private.der -outform der
    将公钥转换成 DER 格式：$ openssl rsa -in public.pem -out public.der -pubin -outform der
    -----------------
</code></pre><h3 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6.数字签名"></a>6.数字签名</h3><h4 id="1-数字签名的应用场景"><a href="#1-数字签名的应用场景" class="headerlink" title="1.数字签名的应用场景"></a>1.数字签名的应用场景</h4><pre><code>答：需要严格验证发送方身份信息情况
</code></pre><h4 id="2-数字签名原理"><a href="#2-数字签名原理" class="headerlink" title="2.数字签名原理"></a>2.数字签名原理</h4><pre><code>1）客户端处理
    ①对&quot;消息&quot;进行 HASH 得到 &quot;消息摘要&quot;
    ②发送方使用自己的私钥对&quot;消息摘要&quot; 加密(数字签名)
    ③把数字签名附着在&quot;报文&quot;的末尾一起发送给接收方
2）服务端处理
    ①对&quot;消息&quot; HASH 得到 &quot;报文摘要&quot;
    ②使用公钥对&quot;数字签名&quot; 解密
    ③对结果进行匹配
</code></pre><p><img src="/Users/nick/Desktop/3.png" alt=""></p>
<h3 id="7-数字证书"><a href="#7-数字证书" class="headerlink" title="7.数字证书"></a>7.数字证书</h3><h4 id="1-简单说明"><a href="#1-简单说明" class="headerlink" title="1.简单说明"></a>1.简单说明</h4><pre><code>证书和驾照很相似，里面记有姓名、组织、地址等个人信息，以及属于此人的公钥，并有认证机构施加数字签名,只要看到公钥证书，我们就可以知道认证机构认证该公钥的确属于此人
</code></pre><h4 id="2-数字证书的内容"><a href="#2-数字证书的内容" class="headerlink" title="2.数字证书的内容"></a>2.数字证书的内容</h4><pre><code>1）公钥
2）认证机构的数字签名
</code></pre><h4 id="3-证书的生成步骤"><a href="#3-证书的生成步骤" class="headerlink" title="3.证书的生成步骤"></a>3.证书的生成步骤</h4><pre><code>1）生成私钥 openssl genrsa -out private.pem 1024
2）创建证书请求 openssl req -new -key private.pem -out rsacert.csr
3）生成证书并签名，有效期10年 openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt
4）将 PEM 格式文件转换成 DER 格式 openssl x509 -outform der -in rsacert.crt -out rsacert.der
5）导出P12文件 openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt
</code></pre><h4 id="4-iOS开发中的注意点"><a href="#4-iOS开发中的注意点" class="headerlink" title="4.iOS开发中的注意点"></a>4.iOS开发中的注意点</h4><pre><code>1）在iOS开发中，不能直接使用 PEM 格式的证书，因为其内部进行了Base64编码，应该使用的是DER的证书，是二进制格式的
2）OpenSSL默认生成的都是PEM格式的证书
</code></pre>]]></content>
      <categories>
        <category>数据安全</category>
      </categories>
      <tags>
        <tag>数据加密</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义View 跳转不同界面方法</title>
    <url>/2016/07/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E7%95%8C%E9%9D%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="自定义View-跳转不同界面方法"><a href="#自定义View-跳转不同界面方法" class="headerlink" title="自定义View 跳转不同界面方法"></a>自定义View 跳转不同界面方法</h2><p>有时候，我们在自定义UIView 的时候 ， 很有可能 会在这个View 进行页面跳转，但是， 你会发现， 那些 push  和  pop 方法  都没什么用  ，那是因为 当一个子view需要接收点击事件，而父view也需要接收点击事件</p>
<p> 当然，你可能会说直接调用mysubview.superView即可，这样做也确实是可以做到，但有时子view是不一定知道有这个特定的父view的存在的，如动态添加子view。</p>
<p> 所以这里就用到了事件处理与传递。</p>
<span id="more"></span>
<h3 id="简单介绍一下"><a href="#简单介绍一下" class="headerlink" title="简单介绍一下"></a>简单介绍一下</h3><ul>
<li>ios当中常用的事件?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 触摸事件</span><br><span class="line">- 加速计事件</span><br><span class="line">- 远程控制事件</span><br></pre></td></tr></table></figure>
<ul>
<li>什么是响应者对象?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">继承了UIResponds的对象我们称它为响应者对象</span><br><span class="line">UIApplication、UIViewController、UIView都继承自UIResponder</span><br><span class="line">因此它们都是响应者对象，都能够接收并处理事件</span><br></pre></td></tr></table></figure>
<ul>
<li>事件是怎么样产生与传递的?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中.</span><br><span class="line">UIApplication会从事件队列中取出最前面的事件，交给主窗口.</span><br><span class="line">主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件</span><br><span class="line">触摸事件的传递是从父控件传递到子控件的.</span><br><span class="line">如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一个控件什么情况下不能够接收事件?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 不接收用户交互时不能够处理事件</span><br><span class="line">         </span><br><span class="line">         userInteractionEnabled = NO</span><br><span class="line">- 当一个控件隐藏的时候不能够接收事件</span><br><span class="line">         </span><br><span class="line">         Hidden = YES的时候</span><br><span class="line">- 当一个控件为透明白时候也不能够接收事件</span><br><span class="line">         </span><br><span class="line">         alpha &lt;=0.01</span><br></pre></td></tr></table></figure>
<h5 id="注意-UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的"><a href="#注意-UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的" class="headerlink" title="注意:UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的"></a>注意:UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的</h5></li>
<li><p>如何寻找最合适的View?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 先判断自己是否能够接收触摸事件,如果能再继续往下判断,</span><br><span class="line">- 再判断触摸的当前点在不在自己的身上.</span><br><span class="line">- 如果在自己身上,UIWindow会从后往前（后创建的子控件开始）遍历子控件,遍历出每一个子控件后,重复前面的两个步骤.</span><br><span class="line">- 如果没有符合条件的子控件,那么它自己就是最适合的View.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>回到主题上来，下面要做的也就是，让子view接收这些事件后，同时把这些事件继续向上传，会一直传到UIApplication为止。而在传的过程中，如果子view接收了这些事件，那么事件会自然终止，我们现在可以做的是同时让子view接收事件，而且还让事件不终止，并继续向上传。</p>
<p>步骤应该是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个全局变量    </span></span><br><span class="line"><span class="built_in">UIViewController</span> *superVC;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后执行这个方法</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)viewController:(<span class="built_in">UIView</span> *)view&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIResponder</span> *responder = view;</span><br><span class="line">    <span class="keyword">while</span> ((responder = [responder nextResponder]))</span><br><span class="line">    <span class="keyword">if</span> ([responder isKindOfClass: [<span class="built_in">UIViewController</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后，在你跳转页面的方法中</span></span><br><span class="line">superVC = [<span class="keyword">self</span> viewController:<span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line">[superVC.navigationController pushViewController:（<span class="built_in">UIViewController</span>） animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>这样就可以跳转页面了.</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义图片下载</title>
    <url>/2019/06/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>学习完SDWebImage第三方框架之后，根据它的流程，试着简写自定义下载图片的方法。</p>
<span id="more"></span>
<h4 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - 单例</span><br><span class="line">static CHImageManager *_sharedInstance;</span><br><span class="line">+ (CHImageManager *)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        if (!_sharedInstance) &#123;</span><br><span class="line">            _sharedInstance = [[CHImageManager alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return _sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedInstance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置URL缓存过滤器并给出方法"><a href="#设置URL缓存过滤器并给出方法" class="headerlink" title="设置URL缓存过滤器并给出方法"></a>设置URL缓存过滤器并给出方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义缓存过滤器的block块</span><br><span class="line">typedef NSString *(^CHImageCacheKeyFilterBlock)(NSURL *url);</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) CHImageCacheKeyFilterBlock cacheKeyFilter; //缓存过滤器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - URL过滤器</span><br><span class="line">//返回指定URL的缓存键值，就是URL字符串</span><br><span class="line">- (NSString *)cacheKeyForURL:(NSURL *)url &#123;</span><br><span class="line">    //如果URL不存在，那么就返回空</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //先判断是否设置了缓存过滤器，如果设置了则走cacheKeyFilterBlock,否则直接把URL转换为字符串之后返回</span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [url absoluteString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要外部自己设置过滤规则 实现cacheKeyFilter相关</p>
<h4 id="自定义下载方法"><a href="#自定义下载方法" class="headerlink" title="自定义下载方法"></a>自定义下载方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)customImageView:(UIImageView *)imageView UrlStr:(NSURL *)urlStr&#123;</span><br><span class="line"></span><br><span class="line">    //容错处理</span><br><span class="line">    if ([urlStr isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        urlStr = [NSURL URLWithString:(NSString *)urlStr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (![urlStr isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        urlStr = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!urlStr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 缓存key</span><br><span class="line">    NSString *cacheKey = [self cacheKeyForURL:urlStr];</span><br><span class="line"></span><br><span class="line">/* 从内存缓存中取 */</span><br><span class="line">    UIImage *image = [self.imagesCache objectForKey:cacheKey];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        // 直接设置</span><br><span class="line">        imageView.image = image;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">/* 检查磁盘缓存 */</span><br><span class="line">        // 获取文件路径</span><br><span class="line">        NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">        // 获取图片名称 获取节点</span><br><span class="line">        NSString *fileName = [cacheKey lastPathComponent];</span><br><span class="line">        // 拼接文件全路径</span><br><span class="line">        NSString *fullPath = [cachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">        // 从磁盘缓存中取</span><br><span class="line">        NSData *data = [NSData dataWithContentsOfFile:fullPath];</span><br><span class="line"></span><br><span class="line">        if (data) &#123;</span><br><span class="line">            // 将二进制数据转成图片</span><br><span class="line">            UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">            // 设置图片</span><br><span class="line">            imageView.image = image;</span><br><span class="line">            // 把图片存到内存缓存中</span><br><span class="line">            [self.imagesCache setObject:image forKey:cacheKey];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">/* 检查操作缓存 */</span><br><span class="line">            // 清空图片或者占位图片</span><br><span class="line">            imageView.image = nil;</span><br><span class="line">            // 检查操作缓存</span><br><span class="line">            NSBlockOperation *downloadOperation = [self.operationsCache objectForKey:cacheKey];</span><br><span class="line">            if (downloadOperation) &#123;</span><br><span class="line">                // 不处理</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                downloadOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">                    // 下载图片三部曲</span><br><span class="line">                    NSData *tempData = [NSData dataWithContentsOfURL:urlStr];</span><br><span class="line">                    UIImage *tempImage = [UIImage imageWithData:tempData];</span><br><span class="line">                    if (tempImage == nil) &#123;</span><br><span class="line">                        // 移除操作缓存中的操作</span><br><span class="line">                        [self.operationsCache removeObjectForKey:cacheKey];</span><br><span class="line">                        return ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 把图片存到内存缓存</span><br><span class="line">                    [self.imagesCache setObject:tempImage forKey:cacheKey];</span><br><span class="line"></span><br><span class="line">                    // 把图片保存到磁盘缓存</span><br><span class="line">                    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">                        [data writeToFile:fullPath atomically:YES];</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    // 回到主线程</span><br><span class="line">                    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                        // 设置图片</span><br><span class="line">                      //imageView.image = tempImage;</span><br><span class="line">                        // 刷新一行(会重新调用cellForRow方法)</span><br><span class="line">                      //[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight];</span><br><span class="line"></span><br><span class="line">                    &#125;];</span><br><span class="line">                &#125;];</span><br><span class="line">                // 添加操作缓存</span><br><span class="line">                [self.operationsCache setObject:downloadOperation forKey:cacheKey];</span><br><span class="line">                // 将操作加入队列</span><br><span class="line">                [self.queue addOperation:downloadOperation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除缓存策略"><a href="#移除缓存策略" class="headerlink" title="移除缓存策略"></a>移除缓存策略</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - 清除缓存</span><br><span class="line">- (void)cleanCache&#123;</span><br><span class="line">    // 内存缓存</span><br><span class="line">    [self.imagesCache removeAllObjects];</span><br><span class="line">    // 操作缓存</span><br><span class="line">    [self.operationsCache removeAllObjects];</span><br><span class="line">    // 取消队列中的操作</span><br><span class="line">    [self.queue cancelAllOperations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是具体实现方法 <a href="/download/CHImageManager.zip">点击查看</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析uni-app</title>
    <url>/2022/04/07/%E6%B5%85%E6%9E%90uni-app/</url>
    <content><![CDATA[<p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。</p>
<span id="more"></span>
<h3 id="Vue-js简介"><a href="#Vue-js简介" class="headerlink" title="Vue.js简介"></a>Vue.js简介</h3><p><img src="/images/vue.png" alt=""><br><a href="https://www.zhihu.com/question/51907207">渐进式框架、自底向上增量开发概念</a></p>
<h4 id="Vue目录结构"><a href="#Vue目录结构" class="headerlink" title="Vue目录结构"></a>Vue目录结构</h4><table>
<thead>
<tr>
<th>目录/文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>build</td>
<td>项目构建(webpack)相关代码</td>
</tr>
<tr>
<td>config</td>
<td>配置目录，包括端口号等。我们初学可以使用默认的。</td>
</tr>
<tr>
<td>node_modules</td>
<td>npm 加载的项目依赖模块</td>
</tr>
<tr>
<td>src</td>
<td>这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。</td>
</tr>
<tr>
<td>static</td>
<td>静态资源目录，如图片、字体等。</td>
</tr>
<tr>
<td>test</td>
<td>初始测试目录，可删除</td>
</tr>
<tr>
<td>.xxxx文件</td>
<td>这些是一些配置文件，包括语法配置，git配置等。</td>
</tr>
<tr>
<td>index.html</td>
<td>首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td>
</tr>
<tr>
<td>package.json</td>
<td>项目配置文件。</td>
</tr>
<tr>
<td>README.md</td>
<td>项目的说明文档，markdown 格式</td>
</tr>
</tbody>
</table>
<h3 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h3><p><img src="/images/uni-app目录结构.png" alt=""></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><img src="/images/uni-app应用生命周期.png" alt=""></p>
<h5 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h5><p><img src="/images/uni-app页面生命周期.png" alt=""></p>
<h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p><img src="/images/uni-app组件生命周期.png" alt=""></p>
<h4 id="页面书写"><a href="#页面书写" class="headerlink" title="页面书写"></a>页面书写</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页面：</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 初始化 属性区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">components: &#123;</span><br><span class="line">    // 引用的组件区</span><br><span class="line">&#125;,</span><br><span class="line">props: &#123;</span><br><span class="line">    // 外界传入 属性区</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    // 方法区</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    ***（需要监听的属性要）: &#123;</span><br><span class="line">        handler: ‘_监听方法名’,</span><br><span class="line">        immediate: true,</span><br><span class="line">        deep: true</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">在自定义组件中 没有 需要映射： https://ask.dcloud.net.cn/article/37086</span><br><span class="line">onPageShow: function()&#123; </span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令是带有 v- 前缀的特殊属性</span><br><span class="line">v-bind </span><br><span class="line">	•	动态绑定 缩写 &#x27;:&#x27;</span><br><span class="line"></span><br><span class="line">v-on   </span><br><span class="line">	•	监听事件 缩写 &#x27;@&#x27;</span><br><span class="line"></span><br><span class="line">v-once </span><br><span class="line">	•	执行一次 </span><br><span class="line"></span><br><span class="line">v-html</span><br><span class="line">	•	更新元素的 innerHTML</span><br><span class="line"></span><br><span class="line">v-if和v-else</span><br><span class="line">	•	条件渲染</span><br><span class="line"></span><br><span class="line">v-show</span><br><span class="line">	•	是否展示</span><br><span class="line"></span><br><span class="line">v-for</span><br><span class="line">	•	列表渲染 item in （优先级大于v-if） </span><br><span class="line">	•	&lt;view v-for=&quot;(item, index) in items” :key=&quot;index&quot;&gt; </span><br><span class="line">	•	在H5平台 item 从 1 开始，其他平台 item 从 0 开始</span><br><span class="line">	•	在组件上使用，必须有key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="对比变化"><a href="#对比变化" class="headerlink" title="对比变化"></a>对比变化</h4><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p>以前是.html文件，开发也是html，运行也是html。 现在是.vue文件，开发是vue，经过编译后，运行时已经变成了js文件。 现代前端开发，很少直接使用HTML，基本都是开发、编译、运行。所以uni-app有编译器、运行时的概念。</p>
<h5 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h5><p>以前一个html大节点，里面有script和style节点；<br>现在template是一级节点，用于写tag组件，script和style是并列的一级节点，也就是有3个一级节点。<br>以前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot; /&gt;  </span><br><span class="line">        &lt;title&gt;&lt;/title&gt;  </span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line"></span><br><span class="line">        &lt;/script&gt;  </span><br><span class="line">        &lt;style type=&quot;text/css&quot;&gt;  </span><br><span class="line"></span><br><span class="line">        &lt;/style&gt;  </span><br><span class="line">    &lt;/head&gt;  </span><br><span class="line">    &lt;body&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>现在。这个叫vue单文件组件规范sfc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">    &lt;view&gt;  </span><br><span class="line">    注意必须有一个view，且只能有一个根view。所有内容写在这个view下面。  </span><br><span class="line">    &lt;/view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    export default &#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">&lt;style&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><ul>
<li>以前的dom操作，改成vue的MVVM模式</li>
</ul>
<p>现在前端趋势是去dom化，改用mvvm模式，更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。</p>
<font color="#d0000">uni-app使用vue的数据绑定方式解决js和dom界面交互的问题。</font>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你想改变某个dom元素的显示内容，比如一个view的显示文字：</span><br><span class="line">以前是给view设id，然后js里通过选择器获取dom元素，进一步通过js进行赋值操作，修改dom元素的属性或值。</span><br><span class="line">&lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">            document.addEventListener(&quot;DOMContentLoaded&quot;,function () &#123;  </span><br><span class="line">                document.getElementById(&quot;spana&quot;).innerText=&quot;456&quot;  </span><br><span class="line">            &#125;)  </span><br><span class="line">            function changetextvalue () &#123;  </span><br><span class="line">                document.getElementById(&quot;spana&quot;).innerText=&quot;789&quot;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &lt;/script&gt;  </span><br><span class="line">    &lt;/head&gt;  </span><br><span class="line">    &lt;body&gt;  </span><br><span class="line">        &lt;span id=&quot;spana&quot;&gt;123&lt;/span&gt;  </span><br><span class="line">        &lt;button type=&quot;button&quot; onclick=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;  </span><br><span class="line">    &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现在的做法，是vue的绑定模式，给这个dom元素绑定一个js变量，在script中修改js变量的值，dom会自动变化，页面会自动更新渲染</span><br><span class="line">&lt;template&gt;  </span><br><span class="line">    &lt;view&gt;  </span><br><span class="line">        &lt;text&gt;&#123;&#123;textvalue&#125;&#125;&lt;/text&gt;&lt;!-- 这里演示了组件值的绑定 --&gt;  </span><br><span class="line">        &lt;button :type=&quot;buttontype&quot; @click=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;&lt;!-- 这里演示了属性和事件的绑定 --&gt;  </span><br><span class="line">    &lt;/view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    export default &#123;  </span><br><span class="line">        data() &#123;  </span><br><span class="line">            return &#123;  </span><br><span class="line">                textvalue:&quot;123&quot;,  </span><br><span class="line">                buttontype:&quot;primary&quot;  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;,  </span><br><span class="line">        onLoad() &#123;  </span><br><span class="line">            this.textvalue=&quot;456&quot;//这里修改textvalue的值，其实123都来不及显示就变成了456  </span><br><span class="line">        &#125;,  </span><br><span class="line">        methods: &#123;  </span><br><span class="line">            changetextvalue() &#123;  </span><br><span class="line">                this.textvalue=&quot;789&quot;//这里修改textvalue的值，页面自动刷新为789  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><font color="#d0000">在vue的设计中，这里存放着页面中需要绑定的数据，写在data里，才能被界面正确的绑定和渲染。</font></p>
<h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><p>标准的css基本都是支持的。<br>选择器有2个变化：*选择器不支持；元素选择器里没有body，改为了page。微信小程序即是如此。</p>
<p>单位方面，px无法动态适应不同宽度的屏幕，rem无法用于nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用rpx，全端支持。</p>
<p>uni-app推荐使用flex布局</p>
<h3 id="跨平台对比"><a href="#跨平台对比" class="headerlink" title="跨平台对比"></a>跨平台对比</h3><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>从头到尾重写Q一套跨平台的U框架，包括U控件、渲染逻辑甚至开发语言。渲染引擎依靠跨平台<br>的Skia图形库来实现，依赖系统的只有图形绘制相关的接口，可以在最大程度上保证不同平台、不<br>同设备的体验一致性，逻辑处理使用支持AOT的Dart语言，执行效率也比JavaScript高得多。</p>
<h4 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h4><p>RN需要一个JS的运行环境，在iOS上直接使用内置的javascriptcore,在Android则使用<br>webkit.org官方开源的jsc.so。此外还集成了其他开源组件，如frescol图片组件，okhttp网络<br>组件等。<br>RN会把应用的JS代码（包括依赖的framework)编译成一个js文件（一般命名为<br>index.ios.bundle),RN的整体框架目标就是为了解释运行这个js脚本文件，如果是js扩<br>展的API,则直接通过bridge调用native方法；如果是UI界面，则映射到virtual DOM这个虚拟<br>的JS数据结构中，通过bridge传递到native,然后根据数据属性设置各个对应的真实native<br>的View。bridge:是一种JS和JAVA代码通信的机制，用bridge函数传入对方module和<br>method即可得到异步回调的结果。</p>
<h4 id="uni-app-1"><a href="#uni-app-1" class="headerlink" title="uni-app"></a>uni-app</h4><p>使用vue的语法 + 微信小程序的标签和API的跨平台前端框架<br>uni-app是webview渲染和weex原生渲染双渲染引擎供开发者选择，是使用weex组件最终渲染原生组件</p>
<h5 id="Weex架构"><a href="#Weex架构" class="headerlink" title="Weex架构"></a>Weex架构</h5><p><img src="/images/Weex架构.png" alt=""><br>（Weex SDK后来的版本直接内置了vue2x）</p>
<p>DSL(领域特定语言)层可以理解为就是前端框架层，也就是用VuE或者其他前端UI库，<br>DSL编写的页面结构，会转换成Virtual Dom(虚拟DOM,DOM的JS对象表示)，Virtua最<br>终会被传递到容器（宿主）上进行解析，最终渲染成原生或者Web控件。</p>
<h5 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h5><p>在RN中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RN 是 React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？</span><br><span class="line">主要的区别在于虚拟 DOM 映射的对象是什么。</span><br><span class="line">React 中虚拟 DOM 最终会映射为浏览器 DOM 树，</span><br><span class="line">而 RN 中虚拟 DOM 会通过 JavaScriptCore 映射为原生控件树。</span><br></pre></td></tr></table></figure>
<p>在WEEX中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weex 会编译构建虚拟 DOM，并发送渲染指令给 RenderEngine 层，</span><br><span class="line">这样，同样一份 JSON 数据，在不同平台的渲染引擎中能够渲染成不同版本的 UI，</span><br><span class="line">这是 Weex 可以实现动态化的原因。</span><br><span class="line">weex 在 RN 的  JS V8 引擎基础上，多了 JS Framework 承当了重要的职责，</span><br><span class="line">它主要负责：管理 Weex 的生命周期；解析 JS Bundle，转为 Virtual DOM，</span><br><span class="line">再通过所在平台不同的 API 构建页面；进行双向的数据交互和响应。</span><br></pre></td></tr></table></figure>
<p>在Flutter中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有三颗重要的树：</span><br><span class="line">· Widget 树：控件树，表示了我们在 dart 代码中所写的控件的结构，</span><br><span class="line">但这只是描述信息，渲染引擎是不认识的。 相当于虚拟的DOM</span><br><span class="line">· Element 数：实际控件树，Flutter 会根据 Widget 树信息生成控件对应的 Element 树，</span><br><span class="line">一个 Widget 通过多次复用可以对应多个 Element 实例，Element 才是我们真正在屏幕上显示的元素。</span><br><span class="line">· RenderObject 树：渲染树，做组件布局渲染工作，包含渲染搭配、布局约束等信息。	</span><br></pre></td></tr></table></figure>
<p>对于跨平台来说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟DOM真正的价值从来都不是性能，而是不管数据怎么变化，</span><br><span class="line">都可以用最小的代价来更新DOM,而且掩盖了底层的DOM操作，</span><br><span class="line">让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://ask.dcloud.net.cn/article/35657">白话uni-app</a><br><a href="https://cn.vuejs.org/v2/guide/single-file-components.html">vue单文件组件规范</a><br><a href="https://uniapp.dcloud.io">uni-app官网</a></p>
]]></content>
  </entry>
  <entry>
    <title>函数式Swift概念</title>
    <url>/2022/05/18/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>我们希望让函数式编程易于理解，并消除人们对它的一些偏见。使用这些理念去改善你的代码并不需要你拥有数学的博士学位！函数式编程并不是 Swift 编程的唯一方式。但是我们相信学习函数式编程会为你的工具箱添加一件重要的新工具，不论你使用那种语言，这件工具都会让你成为一个更好的开发者。<br>引自《函数式Swift》<br><span id="more"></span></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><a href="#什么是面向过程？">什么是面向过程？</a></li>
<li><a href="#什么是函数？">什么是函数？</a></li>
<li><a href="#什么是高阶函数？">什么是高阶函数？</a></li>
<li><a href="#什么是函数式编程？">什么是函数式编程？</a></li>
<li><a href="#什么是纯函数式编程语言？">什么是纯函数式编程语言？</a></li>
<li><a href="#什么是柯里化(Currying">什么是柯里化(Currying)？</a>？)</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h4><p>通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务</p>
<h4 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h4><p>函数是一种封装，是面向过程的程序设计的基本单元。</p>
<h4 id="什么是高阶函数？"><a href="#什么是高阶函数？" class="headerlink" title="什么是高阶函数？"></a>什么是高阶函数？</h4><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>至少满足一个条件：</p>
<ul>
<li>接受一个或多个函数作为输入（map、filter、reduce等）</li>
<li>返回一个函数</li>
</ul>
<h4 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h4><p>（Funtional Programming,简称FP）是一种编程范式，也就是如何编写程序的方法论<br>类似的还有面向协议编程、响应式编程等</p>
<ul>
<li>主要思想：把计算过程尽量分解成一系列可复用函数的调用</li>
<li>主要特征：函数是“第一等公民” ，与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、返回值</li>
<li>支持的语言：Haskell、Scala、javaScript、Python、Swift等</li>
</ul>
<h4 id="什么是纯函数式编程语言？"><a href="#什么是纯函数式编程语言？" class="headerlink" title="什么是纯函数式编程语言？"></a>什么是纯函数式编程语言？</h4><p>纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的<br>swift允许使用变量，所以它和Python一样 不是纯函数式编程语言</p>
<h4 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h4><p>将一个接受多参数的函数变换为一系列只接受单个参数的函数</p>
<h3 id="函数式Swift应该有的特点？"><a href="#函数式Swift应该有的特点？" class="headerlink" title="函数式Swift应该有的特点？"></a>函数式Swift应该有的特点？</h3><ul>
<li><p>模块化：<br>相较于把程序认为是一系列赋值和方法调用，函数式开发者更倾向于强调每个程序都能够被反复分解为越来越小的模块单元，而所有这些块可以通过函数装配起来，以定义一个完整的程序。当然，只有当我们能够避免在两个独立组件之间共享状态时，才能将一个大型程序分解为更小的单元。这引出我们的下一个关注特质。</p>
</li>
<li><p>对可变状态的谨慎处理：<br>函数式编程有时候 (被半开玩笑地) 称为“面向值编程”。面向对象编程专注于类和对象的设计，每个类和对象都有它们自己的封装状态。然而，函数式编程强调基于值编程的重要性，这能使我们免受可变状态或其他一些副作用的困扰。通过避免可变状态，函数式程序比其对应的命令式或者面向对象的程序更容易组合。</p>
</li>
<li><p>类型：<br>最后，一个设计良好的函数式程序在使用类型时应该相当谨慎。精心选择你的数据和函数的类型，将会有助于构建你的代码，这比其他东西都重要。Swift 有一个强大的类型系统，使用得当的话，它能够让你的代码更加安全和健壮。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>swift虽然支持函数式编程，然而在实际开发的时候，纯函数编程并非好的选择，而且由于数据的不可变性放弃了执行机可以反复擦写内存属性，所以并不能做到高效的算法，不能保证性能，但是好在swift是一门支持多编程范式的语言，在合适的地方使用合适的方法才是我们需要去做的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="/download/函数式Swift.zip">函数式Swift 电子书</a><br><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">functors,_applicatives,_and_monads_in_pictures</a><br><a href="https://mokacoding.com/blog/functor-applicative-monads-in-pictures/">Swift Functors, Applicatives, and Monads in Pictures</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
</search>
