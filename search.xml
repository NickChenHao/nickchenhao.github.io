<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RN集成到原生应用</title>
    <url>/2019/07/22/RN%E9%9B%86%E6%88%90%E5%88%B0%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://reactnative.cn/docs/integration-with-existing-apps">集成到现有原生应用</a><br><a href="https://www.jianshu.com/p/ea8dc1e078f1">将RN集成到iOS原生项目中</a><br><a href="https://www.jianshu.com/p/bdaef44c6207">RN嵌入到现有iOS原生应用</a><br><a href="https://www.jianshu.com/p/1927785a3ba7">将RN工程嵌入到现有iOS原生应用</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>虽然看了ReactNative官网还有网上的这些资料，有说怎么集成，但多多少少感觉不太对，写出来也是有问题，所以在这里记录一下集成成功的步骤，减少踩坑！</p>
<span id="more"></span>

<h4 id="步骤-以0-48-4版本RN为例"><a href="#步骤-以0-48-4版本RN为例" class="headerlink" title="步骤 (以0.48.4版本RN为例)"></a>步骤 (以0.48.4版本RN为例)</h4><h5 id="新建相关文件"><a href="#新建相关文件" class="headerlink" title="新建相关文件"></a>新建相关文件</h5><ul>
<li>在原生项目.xcodeproj同级 <code>mkdir RNUntils</code> 新建RNUntils存放RN相关 </li>
<li>在RNUntils目录下 <code>touch package.json</code> 新建文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;RNUntils&quot;, </span><br><span class="line">    &quot;version&quot;: &quot;0.0.1&quot;, </span><br><span class="line">    &quot;private&quot;: true, </span><br><span class="line">    &quot;scripts&quot;: &#123; </span><br><span class="line">        &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot; </span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123; </span><br><span class="line">        &quot;react&quot;: &quot;16.0.0-alpha.12&quot;, </span><br><span class="line">        &quot;react-native&quot;: &quot;0.48.4&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行npm install 会自动生成node_modules</li>
<li>在RNUntils目录下 <code>touch index.js</code> 新建文件</li>
</ul>
<p><font color="#dd0000"><strong>注</strong>：创建一个空的index.js文件。（注意在 0.49 版本之前是 index.ios.js 文件）</font><br /> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;</span><br><span class="line">    AppRegistry,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View</span><br><span class="line">&#125; from &#x27;react-native&#x27;;</span><br><span class="line">export default class DemoApp extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">                &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">                Welcome to React Native!</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                To get started, edit index.ios.js</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                Press Cmd+R to reload,&#123;&#x27;\n&#x27;&#125;</span><br><span class="line">                Cmd+D or shake for dev menu</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">container: &#123;</span><br><span class="line">flex: 1,</span><br><span class="line">justifyContent: &#x27;center&#x27;,</span><br><span class="line">alignItems: &#x27;center&#x27;,</span><br><span class="line">backgroundColor: &#x27;#F5FCFF&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">welcome: &#123;</span><br><span class="line">fontSize: 20,</span><br><span class="line">textAlign: &#x27;center&#x27;,</span><br><span class="line">margin: 10,</span><br><span class="line">&#125;,</span><br><span class="line">instructions: &#123;</span><br><span class="line">textAlign: &#x27;center&#x27;,</span><br><span class="line">color: &#x27;#333333&#x27;,</span><br><span class="line">marginBottom: 5,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">AppRegistry.registerComponent(&#x27;TestReactNative&#x27;, () =&gt; DemoApp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注：此处最后一行代码中的RNHighScores是自定义的rn组件的名字，iOS原生代码调用时需要用到</span><br></pre></td></tr></table></figure>
<ul>
<li>在RNUntils文件下 终端运行 <code>react-native bundle --platform ios --dev false --entry-file index.ios.js --bundle-output main.jsbundle</code> 生成的 main.jsbundle 导入到原生项目中 再运行 <code>npm start</code><ul>
<li><font color="#dd0000">其中 index.ios.js” 根据根目录上的index.js  （0.49版本之前是index.ios.js）</font><br /> </li>
<li>ios&#x2F;main.jsbundle  是根据在xcodeproj同级目录下的路径</li>
</ul>
</li>
<li>编辑podfile文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    # &#x27;node_modules&#x27;目录一般位于根目录中</span><br><span class="line">    # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`</span><br><span class="line">    pod &#x27;React&#x27;, :path =&gt; ‘RNUntils/node_modules/react-native&#x27;, :subspecs =&gt; [</span><br><span class="line">        &#x27;Core&#x27;,</span><br><span class="line">        &#x27;CxxBridge&#x27;, # 如果RN版本 &gt;= 0.47则加入此行</span><br><span class="line">        &#x27;DevSupport&#x27;, # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class="line">        &#x27;RCTText&#x27;,</span><br><span class="line">        &#x27;RCTNetwork&#x27;,</span><br><span class="line">        &#x27;RCTWebSocket&#x27;, # 调试功能需要此模块</span><br><span class="line">        &#x27;RCTAnimation&#x27;, # FlatList和原生动画功能需要此模块</span><br><span class="line">    # 在这里继续添加你所需要的其他RN模块</span><br><span class="line">    ]</span><br><span class="line">    # 如果RN版本 &gt;= 0.42.0，则加入下面这行</span><br><span class="line">    pod &#x27;Yoga&#x27;, :path =&gt; ‘RNUntils/node_modules/react-native/ReactCommon/yoga’</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 <code>pod install</code><br><font color="#dd0000"><strong>注</strong>：(若 0.44.3之后版本 boost pod不下来 <a href="https://juejin.im/post/5c88711df265da2db30591de">解决方案</a>) 貌似换了 更不行 可能和网有关 可以试试！ （更换后 需要先删除pod缓存  ~&#x2F;Library&#x2F;Caches&#x2F;Cocoapods  再pod repo update 再 pod install才可以）<br></font><br /></li>
</ul>
<h5 id="原生调用"><a href="#原生调用" class="headerlink" title="原生调用"></a>原生调用</h5><ul>
<li><p>需要先导入 <code>&lt;React/RCTRootView.h&gt;、&lt;React/RCTBundleURLProvider.h&gt;</code></p>
</li>
<li><p>调用代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	    NSURL *jsCodeLocation = </span><br><span class="line">[[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; </span><br><span class="line">                                               fallbackResource:nil];</span><br><span class="line">    RCTRootView *rootView =</span><br><span class="line">    [[RCTRootView alloc] initWithBundleURL : jsCodeLocation</span><br><span class="line">                         moduleName        : @&quot;TestReactNative&quot; </span><br><span class="line">                         initialProperties :nil </span><br><span class="line">                          launchOptions    : nil]; </span><br><span class="line">    UIViewController *vc = [[UIViewController alloc] init];</span><br><span class="line">    vc.view = rootView;</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#dd0000">其中 @”index” 根据根目录上的index.js  （0.49版本之前是index.ios.js）</font><br /> </li>
<li><code>@&quot;TestReactNative&quot;</code> 是js文件中最后写的名称</li>
</ul>
</li>
<li><p>需要修改info.plist文件<br><img src="/images/RN%E9%9B%86%E6%88%90%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9info%E6%96%87%E4%BB%B6.png"></p>
</li>
</ul>
<hr>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><font color="#dd0000"><em>以上是 在原生项目.xcodeproj同级 新建RNUntils文件存放RN相关 的操作流程<br>以下是 新建RNUntils文件存放RN相关、新建子文件ios 存放原生项目 的操作流程</em><br></font><br /><em>区别在步骤 1、5、6上</em><br>1、新建文件夹专门放RN相关文件如RNUntils  新建子文件夹ios 将原生项目.xcodeproj同级所有文件复制到ios目录下<br>5、终端运行 修改 <code>main.jsbundle</code> 为 <code>ios/main.jsbundle</code><br>6、在 podfile 文件 修改 <code>:path =&gt; &#39;RNUntils/node_modules/react-native</code> 为 <code>:path =&gt; &#39;../node_modules/react-native</code> </p>
]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>siwft笔记3</title>
    <url>/2016/01/27/siwft%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="一-三大特性"><a href="#一-三大特性" class="headerlink" title="一.三大特性"></a>一.三大特性</h3><ul>
<li><p>封装</p>
</li>
<li><p>继承</p>
</li>
<li><p>重写父类方法 需要加上 override</p>
</li>
<li><p>多态</p>
</li>
<li><p>必须要有继承</p>
</li>
<li><p>必须要有重写</p>
</li>
<li><p>必须是父类指针指向子类对象</p>
</li>
<li><p>(重载)</p>
</li>
<li><p>参数类型不同</p>
</li>
<li><p>参数个数不同</p>
</li>
</ul>
<h3 id="二-自动引用计数"><a href="#二-自动引用计数" class="headerlink" title="二.自动引用计数"></a>二.自动引用计数</h3><ul>
<li>当有一个强引用指向某个对象时,该对象的引用计数会自动 + 1</li>
<li>当强引用消失时,引用计数会自动 - 1</li>
<li>当引用计数为0时,该对象会被销毁<span id="more"></span></li>
</ul>
<h5 id="循环引用-的解决"><a href="#循环引用-的解决" class="headerlink" title="循环引用 的解决"></a>循环引用 的解决</h5><p>        1.weak       和OC中的 __weak一样 是弱引用  当指向的对象销毁时,会自动指向nil<br>        2.unowned    和OC中的 __unsefe_unretained   当对象销毁时依然指向原来的位置(容易引起野指针)</p>
<h3 id="三-可选链"><a href="#三-可选链" class="headerlink" title="三.可选链"></a>三.可选链</h3><ul>
<li>如果可选的目标有值,就调用成功</li>
<li>如果没有值,则调用返回空nil</li>
</ul>
<p>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   // OC对象结构体的成员属性不能直接赋值</span><br><span class="line">   titleLabel?.frame.origin.x = 0</span><br></pre></td></tr></table></figure>

<h3 id="四-协议-protocol"><a href="#四-协议-protocol" class="headerlink" title="四.协议  protocol"></a>四.协议  protocol</h3><ul>
<li><h5 id="定义协议和遵守协议"><a href="#定义协议和遵守协议" class="headerlink" title="定义协议和遵守协议"></a>定义协议和遵守协议</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义协议</span><br><span class="line">protocol SportProtocol &#123; </span><br><span class="line">     func playBasketball() </span><br><span class="line">     func playFootball()</span><br><span class="line">&#125;</span><br><span class="line">// 2.遵守协议</span><br><span class="line">// 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错</span><br><span class="line">class Person : SportProtocol &#123; </span><br><span class="line">     var name : String? var age : Int = 0</span><br><span class="line">   // 实现协议中的方法 </span><br><span class="line">     func playBasketball() &#123; </span><br><span class="line">         print(&quot;人在打篮球&quot;) </span><br><span class="line">     &#125;</span><br><span class="line">     func playFootball() &#123; </span><br><span class="line">         print(&quot;人在踢足球&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="协议之间的继承"><a href="#协议之间的继承" class="headerlink" title="协议之间的继承"></a>协议之间的继承</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol CrazySportProtocol &#123;      </span><br><span class="line">      func jumping()</span><br><span class="line">&#125;</span><br><span class="line">protocol SportProtocol : CrazySportProtocol &#123;</span><br><span class="line">     func playBasketball()   </span><br><span class="line">     func playFootball()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="协议中方法的可选-需加-objc-和-optional-关键字"><a href="#协议中方法的可选-需加-objc-和-optional-关键字" class="headerlink" title="协议中方法的可选  需加 @objc 和 optional 关键字"></a>协议中方法的可选  需加 @objc 和 optional 关键字</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义协议</span><br><span class="line">@objc</span><br><span class="line">protocol SportProtocol &#123;</span><br><span class="line">    func playBasketball()</span><br><span class="line">    optional func playFootball()</span><br><span class="line">&#125;</span><br><span class="line">// 2.遵守协议</span><br><span class="line">class Person : SportProtocol &#123;</span><br><span class="line">    var name : String?</span><br><span class="line">    var age : Int = 0</span><br><span class="line">    // 实现协议中的方法</span><br><span class="line">    @objc func playBasketball() &#123;</span><br><span class="line">        print(&quot;人在打篮球&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义协议属性 用 weak 且协议后面需 : class 才不会报错</span><br><span class="line">protocol BuyTicketProtocol : class &#123;</span><br><span class="line">    func buyTicket()&#125;class Person &#123;    // 1.定义协议属性</span><br><span class="line">    weak var delegate : BuyTicketProtocol</span><br><span class="line">    func goToHeFei()&#123;</span><br><span class="line">        delegate?.buyTicketing()</span><br><span class="line">        print(&quot;去北京&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;class Huangniu: BuyTicketDelegate &#123;</span><br><span class="line">    func buyTicketing() &#123;</span><br><span class="line">        print(&quot;买票&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理对象</span><br><span class="line">//设置代理时 没有self   需要先 let 创建代理对象  然后再 设置代理 = 代理对象</span><br><span class="line">let h = Huangniu()</span><br><span class="line">let p = Person()</span><br><span class="line">p.delegate = h</span><br><span class="line">p.goToHeFei()    </span><br></pre></td></tr></table></figure>
<h3 id="五-闭包-类似OC中的Block"><a href="#五-闭包-类似OC中的Block" class="headerlink" title="五.闭包 (类似OC中的Block)"></a>五.闭包 (类似OC中的Block)</h3><ul>
<li>block的写法:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    类型:    返回值(^block的名称)(block的参数)</span><br><span class="line">    值:</span><br><span class="line">    ^(参数列表) &#123;</span><br><span class="line">        // 执行的代码</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的写法:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    类型:(形参列表)-&gt;(返回值)</span><br><span class="line">    技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值</span><br><span class="line">    值:</span><br><span class="line">    &#123;</span><br><span class="line">        (形参) -&gt; 返回值类型 in</span><br><span class="line">        // 执行代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的循环引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> 需要用到self的地方:</span><br><span class="line">     1.如果某一个方法中,有局部变量和成员变量产生歧义,可以使用self进行区分</span><br><span class="line">     2.如果在闭包中使用到当前对象的方法或者属性,都需要加self</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 解决方案一:</span><br><span class="line">        weak var weakself : ViewController? = self</span><br><span class="line">        httpTool?.loadData(&#123; (jsonData) -&gt; () in</span><br><span class="line">        weakself?.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;)</span><br><span class="line">// 解决方案二:(推荐)</span><br><span class="line">        httpTool?.loadData(&#123;[weak self] (jsonData) -&gt; () in            self?.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="六-懒加载"><a href="#六-懒加载" class="headerlink" title="六.懒加载"></a>六.懒加载</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazy var 变量: 类型 = &#123; 创建变量代码 &#125;()</span><br></pre></td></tr></table></figure>
<ul>
<li>懒加载的使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 懒加载的本质是,在第一次使用的时候执行闭包,将闭包的返回值赋值给属性</span><br><span class="line">// lazy的作用是只会赋值一次</span><br><span class="line">    lazy var array : [String] = &#123;</span><br><span class="line">        return [&quot;why&quot;, &quot;lmj&quot;, &quot;lnj&quot;]</span><br><span class="line">    &#125;()</span><br><span class="line">     lazy var btn : UIButton = &#123;</span><br><span class="line">        let tempBtn = UIButton()</span><br><span class="line">        tempBtn.setTitle(&quot;按钮&quot;, forState: .Normal)</span><br><span class="line">        return tempBtn</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>
<h3 id="七-常见注释"><a href="#七-常见注释" class="headerlink" title="七.常见注释"></a>七.常见注释</h3><ul>
<li>单行注释</li>
</ul>
<p> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注释内容</span><br></pre></td></tr></table></figure>
<ul>
<li>多行注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">(与OC不同  可以多行嵌套多行注释) </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注释内容</span><br></pre></td></tr></table></figure>
<ul>
<li>分组注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MARK:-</span><br></pre></td></tr></table></figure>
<h3 id="八-访问权限"><a href="#八-访问权限" class="headerlink" title="八.访问权限"></a>八.访问权限</h3><ul>
<li>Swift 中的访问控制模型基于模块和源文件这两个概念</li>
<li>private : 修饰源文件,在当前源文件中可以访问</li>
<li>internal : 内部的,修饰整个项目,在整个项目中都可以进行访问,并且默认修饰的就是internal</li>
<li>public :  修饰整个项目,可以跨框架使用   <br> (在class 和 func前面加)</li>
</ul>
<h3 id="九-处理异常-三种方式"><a href="#九-处理异常-三种方式" class="headerlink" title="九.处理异常  (三种方式)"></a>九.处理异常  (三种方式)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 3.异常的处理三种方式</span><br><span class="line">// 3.1.try方式,需要手动处理异常do &#123;</span><br><span class="line">    let result = try readFileContent(&quot;abc&quot;)&#125; catch &#123;</span><br><span class="line">    print(error)&#125;</span><br><span class="line">// 3.2.try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值</span><br><span class="line">// 最终返回结果为一个可选类型let result = try? readFileContent(&quot;abc&quot;)</span><br><span class="line">// 3.3.try!方法,告诉系统该方法没有异常.</span><br><span class="line">// 注意:如果出现了异常,则程序会崩溃</span><br><span class="line">    let result = try! readFileContent(&quot;abc&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">// 1.定义异常enum FileReadError : ErrorType &#123;</span><br><span class="line">    case FileISNull</span><br><span class="line">    case FileNotFound</span><br><span class="line">&#125;</span><br><span class="line">// 2.改进方法,让方法抛出异常</span><br><span class="line">func readFileContent(filePath : String) throws -&gt; String &#123;</span><br><span class="line">    // 1.filePath为&quot;&quot;</span><br><span class="line">    if filePath == &quot;&quot; &#123;</span><br><span class="line">        throw FileReadError.FileISNull</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.filepath有值,但是没有对应的文件  </span><br><span class="line">    if filePath != &quot;/User/Desktop/123.plist&quot; &#123;        throw FileReadError.FileISNull    &#125;    // 3.取出其中的内容    return &quot;123&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十-桥接"><a href="#十-桥接" class="headerlink" title="十.桥接"></a>十.桥接</h3><ul>
<li>OC调用swift</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.直接写入一个头文件:  项目名字-Swift.h      </span><br><span class="line">#import &quot;项目名字-Swift.h&quot;</span><br><span class="line"></span><br><span class="line">2.在swift中 添加public关键字 在class和func前面</span><br><span class="line"> (还是以OC格式书写)</span><br></pre></td></tr></table></figure>
<ul>
<li>swift调用OC</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.建立桥接文件  Bridge.h  里面放 .h头文件</span><br><span class="line">2.在项目中Build Settings 配置文件  搜索bird  </span><br><span class="line">然后将Bridge.h路径存入(类似PCH文件)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage初探</title>
    <url>/2019/06/12/SDWebImage%E5%88%9D%E7%BA%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>记录一下SDWebImage第三方源码的研究</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/images/SDWebImage%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存</span><br><span class="line">如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来</span><br><span class="line">如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片</span><br><span class="line">下载后的图片会加入缓存中，并写入磁盘中</span><br><span class="line">整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来</span><br></pre></td></tr></table></figure>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - 检查图片缓存</span><br><span class="line">    //从内存缓存中取出</span><br><span class="line">    if(有图片)</span><br><span class="line">    &#123;</span><br><span class="line">        //直接设置</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">#pragma mark - 检查磁盘缓存</span><br><span class="line">    //获取文件路径</span><br><span class="line"></span><br><span class="line">    //得到图片的名称 获取节点</span><br><span class="line"></span><br><span class="line">    //拼接文件的全路径</span><br><span class="line"></span><br><span class="line">    //从磁盘缓存中取出</span><br><span class="line"></span><br><span class="line">    if(data)</span><br><span class="line">    &#123;   //将二进制数去转成图片</span><br><span class="line"></span><br><span class="line">        //设置图片</span><br><span class="line"></span><br><span class="line">        //把图片存到内存缓存中</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">#pragma mark - 检查操作缓存</span><br><span class="line">        //清空图片或者是设置占位图片</span><br><span class="line"></span><br><span class="line">        //检查操作缓存</span><br><span class="line"></span><br><span class="line">        if (操作缓存) &#123;</span><br><span class="line">            //如果存在,那么什么都不做</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //操作步骤</span><br><span class="line">            &#123;</span><br><span class="line">                //下载图片三步骤</span><br><span class="line">                if (图片为空) &#123;</span><br><span class="line">                    //移除操作缓存中的操作</span><br><span class="line"></span><br><span class="line">                    //直接返回</span><br><span class="line">                    return ;</span><br><span class="line">                &#125;</span><br><span class="line">                //把图片存到内存缓存中</span><br><span class="line"></span><br><span class="line">                //把图片保存到磁盘缓存</span><br><span class="line"></span><br><span class="line">                //回到主线程设置图片</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //添加操作到缓存中</span><br><span class="line"></span><br><span class="line">            //将操作加入队列</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#pragma mark - 移除缓存策略</span><br><span class="line">    //移除内存缓存</span><br><span class="line"></span><br><span class="line">    //取消队列中的操作</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下载图片的核心方法</span><br><span class="line">/*</span><br><span class="line"> * url          图片的二进制数据</span><br><span class="line"> * placeholder  UIImageView的占位图片</span><br><span class="line"> * options      图片下载选项（策略）</span><br><span class="line"> * progressBlock    进度回调</span><br><span class="line"> * completedBlock   完成回调</span><br><span class="line"> */</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line"></span><br><span class="line">    // 取消当前图像下载</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line"></span><br><span class="line">    // 利用运行时retain url</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    //判断，如果传入的下载策略不是延迟显示占位图片，那么在主线程中设置占位图片</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            // 设置占位图像</span><br><span class="line">            self.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果url不为空</span><br><span class="line">    if (url) &#123;</span><br><span class="line"></span><br><span class="line">        // check if activityView is enabled or not</span><br><span class="line">        //检查activityView是否可用</span><br><span class="line">        if ([self showActivityIndicatorView]) &#123;</span><br><span class="line">            [self addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        // 实例化 SDWebImageOperation 操作</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            //移除UIActivityIndicatorView</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            if (!wself) return;</span><br><span class="line"></span><br><span class="line">            //下面block中的操作在主线程中处理</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!wself) return;</span><br><span class="line">                //如果图片下载完成，且传入的下载选项为手动设置图片则直接执行completedBlock回调，并返回</span><br><span class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (image) &#123;   //否则，如果图片存在，则设置图片到UIImageView上面，并刷新重绘视图</span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果没有得到图像</span><br><span class="line">                    //如果传入的下载选项为延迟显示占位图片，则设置占位图片到UIImageView上面，并刷新重绘视图</span><br><span class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果url为空，则在主线中处理下面的操作</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            //移除UIActivityIndicatorView</span><br><span class="line">            [self removeActivityIndicator];</span><br><span class="line"></span><br><span class="line">            //处理错误信息，并执行任务结束回调，把错误信息作为参数传递出去</span><br><span class="line">            NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下载操作队列"><a href="#下载操作队列" class="headerlink" title="下载操作队列"></a>下载操作队列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片 ，否则返回缓存的图像</span><br><span class="line"> *</span><br><span class="line"> * @param url 图片的URL地址</span><br><span class="line"> * @param options 指定此次请求策略的选项</span><br><span class="line"> * @param progressBlock 图片下载进度的回调</span><br><span class="line"> * @param completedBlock 操作完成后的回调</span><br><span class="line"> *      此参数是必须的，此block没有返回值</span><br><span class="line"> *      Image：请求的 UIImage，如果出现错误，image参数是nil</span><br><span class="line"> *      error：如果出现错误，则error有值</span><br><span class="line"> *      cacheType：`SDImageCacheType` 枚举，标示该图像的加载方式</span><br><span class="line"> *          SDImageCacheTypeNone：从网络下载</span><br><span class="line"> *          SDImageCacheTypeDisk：从本地缓存加载</span><br><span class="line"> *          SDImageCacheTypeMemory：从内存缓存加载</span><br><span class="line"> *          finished：如果图像下载完成则为YES，如果使用 SDWebImageProgressiveDownload 选项，同时只获取到部分图片时，返回 NO</span><br><span class="line"> *          imageURL：图片的URL地址</span><br><span class="line"> *</span><br><span class="line"> * @return SDWebImageOperation对象，应该是SDWebimageDownloaderOperation实例</span><br><span class="line"> */</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    //没有completedblock，那么调用这个方法是毫无意义的</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won&#x27;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    //检查用户传入的URL是否正确，如果该URL是NSString类型的，那么尝试转换</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    //防止因参数类型错误而导致应用程序崩溃，判断URL是否是NSURL类型的，如果不是则直接设置为nil</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化一个SDWebImageCombinedOperationBlock块</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;  //初始化设定该URL是正确的</span><br><span class="line"></span><br><span class="line">    //加互斥锁，检索请求图片的URL是否在曾下载失败的集合中（URL黑名单）</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果url不正确或者 选择的下载策略不是『下载失败尝试重新下载』且该URL存在于黑名单中，那么直接返回，回调任务完成block块，传递错误信息</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line"></span><br><span class="line">        //该宏保证了completedBlock回调在主线程中执行</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加互斥锁，把当前的下载任务添加到『当前正在执行任务数组』中</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    //得到该URL对应的缓存KEY</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">    //该方法查找URLKEY对应的图片缓存是否存在，查找完毕之后把该图片（存在|不存在）和该图片的缓存方法以block的方式传递</span><br><span class="line">    //缓存情况查找完毕之后，在block块中进行后续处理（如果该图片没有缓存·下载|如果缓存存在|如果用户设置了下载的缓存策略是刷新缓存如何处理等等）</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        //先判断该下载操作是否已经被取消，如果被取消则把当前操作从runningOperations数组中移除，并直接返回</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //（图片不存在||下载策略为刷新缓存）且（shouldDownloadImageForURL不能响应||该图片存在缓存）</span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            //从此处开始，一直在处理downloaderOptions（即下载策略）</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;   //如果图像存在，但是下载策略为刷新缓存，则通知缓存图像并尝试重新下载</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            //如果下载策略为SDWebImageLowPriority 那么downloaderOptions = 其本身</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; //如果图片存在，且下载策略为刷新刷新缓存</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                //如果图像已缓存，但需要刷新缓存，那么强制进行刷新</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                //忽略从NSURLCache读取图片</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            //到此处位置，downloaderOptions（即下载策略）处理操作结束</span><br><span class="line"></span><br><span class="line">            //核心方法：使用下载器，下载图片</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                if (weakOperation.isCancelled) &#123;</span><br><span class="line">                    //如果此时操作被取消，那么什么也不做</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) &#123; //如果下载失败，则处理结束的回调，在合适的情况下把对应图片的URL添加到黑名单中</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;//下载成功</span><br><span class="line">                    //先判断当前的下载策略是否是SDWebImageRetryFailed，如果是那么把该URL从黑名单中删除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //是否要进行磁盘缓存？</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    //如果下载策略为SDWebImageRefreshCached且该图片缓存中存在且未下载下来，那么什么都不做</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        //否则，如果下载图片存在且（不是可动画图片数组||下载策略为SDWebImageTransformAnimatedImage&amp;&amp;transformDownloadedImage方法可用）</span><br><span class="line">                        //开子线程处理</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            //在下载后立即将图像转换，并进行磁盘和内存缓存</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            //在主线程中回调completedBlock</span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        //得到下载的图片且已经完成，则进行缓存处理</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:operation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            //处理cancelBlock</span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line"></span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    [self.runningOperations removeObject:weakOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123;   //如果图片存在，且操作没有被取消，那么在主线程中回调completedBlock，并把当前操作移除</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            //图片不存在缓存且不允许代理下载，那么在主线程中回调completedBlock，并把当前操作移除</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存及磁盘操作"><a href="#缓存及磁盘操作" class="headerlink" title="缓存及磁盘操作"></a>缓存及磁盘操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//检查要下载图片的缓存情况</span><br><span class="line">/*</span><br><span class="line"> 1.先检查是否有内存缓存</span><br><span class="line"> 2.如果没有内存缓存则检查是否有沙盒缓存</span><br><span class="line"> 3.如果有沙盒缓存，则对该图片进行内存缓存处理并执行doneBlock回调</span><br><span class="line"> */</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line"></span><br><span class="line">    //如果回调不存在，则直接返回</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果缓存对应的key为空，则直接返回，并把存储方式（无缓存）通过block块以参数的形式传递</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    //检查该KEY对应的内存缓存，如果存在内存缓存，则直接返回，并把图片和存储方式（内存缓存）通过block块以参数的形式传递</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     //创建一个操作</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    //使用异步函数，添加任务到串行队列中（会开启一个子线程处理block块中的任务）</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">         //如果当前的操作被取消，则直接返回</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //检查该KEY对应的磁盘缓存</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            //如果存在磁盘缓存，且应该把该图片保存一份到内存缓存中，则先计算该图片的cost(成本）并把该图片保存到内存缓存中</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                //计算图片的Cost</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                //对该图片进行内存缓存处理</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             //线程间通信，在主线程中回调doneBlock，并把图片和存储方式（磁盘缓存）通过block块以参数的形式传递</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注：（磁盘缓存目录）"><a href="#注：（磁盘缓存目录）" class="headerlink" title="注：（磁盘缓存目录）"></a>注：（磁盘缓存目录）</h4><p>缓存在磁盘沙盒目录下 <code>Library/Caches</code><br>二级目录为 <code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark SDImageCache Life Cycle</span><br><span class="line"></span><br><span class="line">//初始化方法，默认的缓存空间名称为default</span><br><span class="line">- (id)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用指定的命名空间实例化一个新的缓存存储</span><br><span class="line">- (id)initWithNamespace:(NSString *)ns &#123;</span><br><span class="line">    //根据传入的命名空间设置磁盘缓存路径</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用指定的命名空间实例化一个新的缓存存储和目录</span><br><span class="line">//拼接完成的结果为：沙盒--》caches路径--》default--》com.hackemist.SDWebImageCache.default</span><br><span class="line">- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line"></span><br><span class="line">        //拼接默认的磁盘缓存目录</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line"></span><br><span class="line">        // initialise PNG signature data</span><br><span class="line">        // 初始化PNG数据签名 8字节</span><br><span class="line">        kPNGSignatureData = [NSData dataWithBytes:kPNGSignatureBytes length:8];</span><br><span class="line"></span><br><span class="line">        // Create IO serial queue</span><br><span class="line">        // 创建处理IO操作的串行队列</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        // Init default values</span><br><span class="line">        // 初始化默认的最大缓存时间 == 1周</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line"></span><br><span class="line">        // Init the memory cache</span><br><span class="line">        // 初始化内存缓存，使用NSCache(AutoPurgeCache)</span><br><span class="line">        _memCache = [[AutoPurgeCache alloc] init];</span><br><span class="line"></span><br><span class="line">        //设置默认的缓存磁盘目录</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // Init the disk cache</span><br><span class="line">        //初始化磁盘缓存，如果磁盘缓存路径不存在则设置为默认值，否则根据命名空间重新设置</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            //以默认值得方式拼接</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据命名空间重新设置</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set decompression to YES</span><br><span class="line">        // 设置图片是否解压缩，默认为YES</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line"></span><br><span class="line">        // memory cache enabled</span><br><span class="line">        // 是否进行内存缓存（默认为YES）</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line"></span><br><span class="line">        // Disable iCloud</span><br><span class="line">        // 是否禁用iCloud备份,默认为YES</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line"></span><br><span class="line">        //同步函数+串行队列：在当前线程中同步的初始化文件管理者</span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            _fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IOS</span><br><span class="line">        // Subscribe to app events</span><br><span class="line">        //监听应用程序通知</span><br><span class="line">        //当监听到UIApplicationDidReceiveMemoryWarningNotification（系统级内存警告）调用clearMemory方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(clearMemory)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        //当监听到UIApplicationWillTerminateNotification（程序将终止）调用cleanDisk方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(cleanDisk)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        //当监听到UIApplicationDidEnterBackgroundNotification（进入后台），调用backgroundCleanDisk方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundCleanDisk)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遇到过的两种需求"><a href="#遇到过的两种需求" class="headerlink" title="遇到过的两种需求"></a>遇到过的两种需求</h4><p>一、图片进过加密处理，一段时间内可以访问，即图片地址后面跟的参数不同，但加载出来的图片是同一张，为了不重复下载，如何过滤图片地址？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法： 写在viewDidLoad 或者 appDelegate里</span><br><span class="line"></span><br><span class="line">1.版本5.0之前</span><br><span class="line">// URL过滤器</span><br><span class="line">[[SDWebImageManager sharedManager] setCacheKeyFilter:^NSString * _Nullable(NSURL * _Nullable url) &#123;</span><br><span class="line">    // 去除参数 ？后面的</span><br><span class="line">    url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">    return [url relativeString];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">2.版本5.0之后</span><br><span class="line">// URL过滤器</span><br><span class="line">SDWebImageCacheKeyFilter *filter = [[SDWebImageCacheKeyFilter alloc] initWithBlock:^NSString * _Nullable(NSURL * _Nonnull url) &#123;</span><br><span class="line">    // 去除参数 ？后面的</span><br><span class="line">    url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">    return [url relativeString];</span><br><span class="line">&#125;];</span><br><span class="line">[[SDWebImageManager sharedManager] setCacheKeyFilter:filter];</span><br></pre></td></tr></table></figure>
<p>二、如何做到tableView滚动时 不加载cell中的图片，停止滚动或减速时才加图片？</p>
<p>需要用到的核心方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> * 根据图片的url下载图片并设置到ImageView上面去，占位图片</span><br><span class="line"> * 异步下载并缓存</span><br><span class="line"> *</span><br><span class="line"> * @param url            图片的URL</span><br><span class="line"> * @param placeholder   显示在UIImageView上面的占位图片，直到图片下载完成</span><br><span class="line"> * @param options       下载图片的选项。参考SDWebImageOptions的枚举值</span><br><span class="line"> * @param completedBlock 当操作执行完毕之后的回调。该回调没有返回值</span><br><span class="line"> *      第一个参数为请求的图片</span><br><span class="line"> *      第二个参数是NSError类型的，如果图片下载成功则error为nil,否则error有值</span><br><span class="line"> *      第三个参数是图片缓存的使用情况（内存缓存|沙盒缓存|直接下载）</span><br><span class="line"> *      第四个参数是图片的URL地址</span><br><span class="line"> */</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options completed:(SDWebImageCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>SDWebImageOptions 枚举类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用位移枚举，通过按位与&amp;按位或|的组合方式传递多个值</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won&#x27;t keep trying.</span><br><span class="line">     * This flag disable this blacklisting.</span><br><span class="line">     *</span><br><span class="line">     * 默认情况下，如果一个url在下载的时候失败了，那么这个url会被加入黑名单，不会尝试再次下载。如果使用该参数，则该URL不会被添加到黑名单中。意味着会对下载失败的URL尝试重新下载。</span><br><span class="line">     * 此标记取消黑名单</span><br><span class="line">     */</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0, //失败后尝试重新下载</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * By default, image downloads are started during UI interactions, this flags disable this feature,</span><br><span class="line">     * leading to delayed download on UIScrollView deceleration for instance.</span><br><span class="line">     *</span><br><span class="line">     * 默认情况下，在 UI 交互时也会启动图像下载，此标记取消这一特性</span><br><span class="line">     * 会推迟到滚动视图停止滚动之后再继续下载</span><br><span class="line">     * 备注：NSURLConnection 的网络下载事件监听的运行循环模式是 NSDefaultRunLoopMode</span><br><span class="line">     */</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,//低优先级</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * This flag disables on-disk caching</span><br><span class="line">     *</span><br><span class="line">     * 使用该参数，将禁止磁盘缓存，只做内存缓存</span><br><span class="line">     */</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只使用内存缓存</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * This flag enables progressive download, the image is displayed progressively during download as a browser would do.</span><br><span class="line">     * By default, the image is only displayed once completely downloaded.</span><br><span class="line">     *</span><br><span class="line">     * 此标记允许渐进式下载，就像浏览器中那样，下载过程中，图像会逐步显示出来</span><br><span class="line">     * 默认情况下，图像会在下载完成后一次性显示</span><br><span class="line">     */</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,//渐进式下载</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.</span><br><span class="line">     * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.</span><br><span class="line">     * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.</span><br><span class="line">     * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.</span><br><span class="line">     *</span><br><span class="line">     * Use this flag only if you can&#x27;t make your URLs static with embedded cache busting parameter.</span><br><span class="line">     *</span><br><span class="line">     * 遵守 HTPP 响应的缓存控制，如果需要，从远程刷新图像</span><br><span class="line">     * 磁盘缓存将由 NSURLCache 处理，而不是 SDWebImage，这会对性能有轻微的影响</span><br><span class="line">     * 此选项用于处理URL指向图片发生变化的情况</span><br><span class="line">     * 如果缓存的图像被刷新，会调用一次 completion block，并传递最终的图像</span><br><span class="line">     */</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4, //刷新缓存</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span><br><span class="line">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span><br><span class="line">     *</span><br><span class="line">     * 如果系统版本是iOS 4+的，那么当App进入后台后仍然会继续下载图像。</span><br><span class="line">     * 这是向系统请求额外的后台时间以保证下载请求完成的</span><br><span class="line">     * 如果后台任务过期，请求将会被取消</span><br><span class="line">     */</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,    //后台下载</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Handles cookies stored in NSHTTPCookieStore by setting</span><br><span class="line">     * NSMutableURLRequest.HTTPShouldHandleCookies = YES;</span><br><span class="line">     *</span><br><span class="line">     * 通过设置，处理保存在 NSHTTPCookieStore 中的 cookies</span><br><span class="line">     */</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,    //处理保存在NSHTTPCookieStore中的cookies</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Enable to allow untrusted SSL certificates.</span><br><span class="line">     * Useful for testing purposes. Use with caution in production.</span><br><span class="line">     *</span><br><span class="line">     * 允许不信任的 SSL 证书</span><br><span class="line">     * 可以出于测试目的使用，在正式产品中慎用</span><br><span class="line">     */</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,  //允许不信任的 SSL 证书</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * By default, image are loaded in the order they were queued. This flag move them to</span><br><span class="line">     * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which</span><br><span class="line">     * could take a while).</span><br><span class="line">     *</span><br><span class="line">     *  默认情况下，图像会按照添加到队列中的顺序被加载，此标记会将它们移动到队列前端被立即加载</span><br><span class="line">     *  而不是等待当前队列被加载，因为等待队列加载会需要一段时间</span><br><span class="line">     */</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,     //高优先级（优先下载）</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span><br><span class="line">     * of the placeholder image until after the image has finished loading.</span><br><span class="line">     *</span><br><span class="line">     * 默认情况下，在加载图像时，占位图像已经会被加载。</span><br><span class="line">     * 此标记会延迟加载占位图像，直到图像已经完成加载</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,    //延迟占位图片</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * We usually don&#x27;t call transformDownloadedImage delegate method on animated images,</span><br><span class="line">     * as most transformation code would mangle it.</span><br><span class="line">     * Use this flag to transform them anyway.</span><br><span class="line">     *</span><br><span class="line">     * 通常不会在可动画的图像上调用transformDownloadedImage代理方法，因为大多数转换代码会破坏动画文件</span><br><span class="line">     * 使用此标记尝试转换</span><br><span class="line">     */</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, //转换动画图像</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * By default, image is added to the imageView after download. But in some cases, we want to</span><br><span class="line">     * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance)</span><br><span class="line">     * Use this flag if you want to manually set the image in the completion when success</span><br><span class="line">     *</span><br><span class="line">     * 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上</span><br><span class="line">     */</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11   //手动设置图像</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参数填成以下就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options: SDWebImageRetryFailed |SDWebImageLowPriority</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>gif转成Lottie的一种方法</title>
    <url>/2025/01/08/gif%E8%BD%AC%E6%88%90Lottie%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>起因是 UI 设计 给不了 Lottie 带颜色的动画，说是 AE 加入颜色导出会报错，只能用 gif 代替。。。</p>
<p>AE 研究不了，那就看看 gif 怎么转成 Lottie 方法吧</p>
<span id="more"></span>

<p>网上找了好多在线转的，都不太理想。<br>目前只有先将 Gif 转成 MP4：<a href="https://ezgif.com/gif-to-mp4">https://ezgif.com/gif-to-mp4</a><br>再将 MP4 转成 Lottie：<a href="https://observablehq.com/@forresto/video-to-lottie">https://observablehq.com/@forresto/video-to-lottie</a><br>因为 gif 中的动画背景是透明的，所以 MP4 转成 Lottie 的网站中需要将 <code>extractFrames方法</code>替换成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function extractFrames(&#123;</span><br><span class="line">  videoEl,</span><br><span class="line">  clipStart,</span><br><span class="line">  clipEnd,</span><br><span class="line">  numFrames,</span><br><span class="line">  quality = 0.8,</span><br><span class="line">  outputScale = 1,</span><br><span class="line">  alpha = 1 // 设置透明度 (1: 完全不透明)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // 暂停视频播放</span><br><span class="line">  videoEl.pause();</span><br><span class="line"></span><br><span class="line">  const canvas = document.createElement(&#x27;canvas&#x27;);</span><br><span class="line">  const context = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line">  const outputWidth = outputScale * videoEl.videoWidth;</span><br><span class="line">  const outputHeight = outputScale * videoEl.videoHeight;</span><br><span class="line">  canvas.width = outputWidth;</span><br><span class="line">  canvas.height = outputHeight;</span><br><span class="line"></span><br><span class="line">  const frames = [];</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; numFrames; i++) &#123;</span><br><span class="line">    const duration = clipEnd - clipStart;</span><br><span class="line">    if (duration &lt;= 0) &#123;</span><br><span class="line">      throw new Error(&#x27;clipEnd is before clipStart&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const time = i * (duration / (Math.max(2, numFrames) - 1)) + clipStart;</span><br><span class="line"></span><br><span class="line">    // 跳转到指定时间</span><br><span class="line">    const seekedTime = await seekTo(videoEl, time);</span><br><span class="line"></span><br><span class="line">    // 清空 Canvas 背景，确保透明</span><br><span class="line">    context.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    // 设置全局透明度</span><br><span class="line">    context.globalAlpha = alpha;</span><br><span class="line"></span><br><span class="line">    // 绘制视频帧到 Canvas</span><br><span class="line">    context.drawImage(videoEl, 0, 0, outputWidth, outputHeight);</span><br><span class="line"></span><br><span class="line">    // 获取帧像素数据</span><br><span class="line">    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);</span><br><span class="line">    const data = imageData.data;</span><br><span class="line"></span><br><span class="line">    // 将白色像素（或近似白色）改为透明</span><br><span class="line">    for (let j = 0; j &lt; data.length; j += 4) &#123;</span><br><span class="line">      const r = data[j];     // 红色通道</span><br><span class="line">      const g = data[j + 1]; // 绿色通道</span><br><span class="line">      const b = data[j + 2]; // 蓝色通道</span><br><span class="line">      const a = data[j + 3]; // 透明度通道</span><br><span class="line"></span><br><span class="line">      // 判断是否是白色（或接近白色）</span><br><span class="line">      if (r &gt; 240 &amp;&amp; g &gt; 240 &amp;&amp; b &gt; 240 &amp;&amp; a &gt; 0) &#123;</span><br><span class="line">        // 将其改为透明</span><br><span class="line">        data[j + 3] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将修改后的像素数据写回 Canvas</span><br><span class="line">    context.putImageData(imageData, 0, 0);</span><br><span class="line"></span><br><span class="line">    // 将帧数据存储为透明背景的 PNG</span><br><span class="line">    frames.push(&#123;</span><br><span class="line">      time,</span><br><span class="line">      seekedTime,</span><br><span class="line">      data: canvas.toDataURL(&#x27;image/png&#x27;, quality) // 输出透明背景帧</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return frames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有<code>lottie.layers.push 中的jpg</code>改成 png 使其支持 alpha 通道<br>其他不用改变 按步骤上传视频 然后导出就行了！</p>
<p>这样 Lottie 动画就是带颜色的啦～</p>
]]></content>
  </entry>
  <entry>
    <title>iOS 无埋点数据统计方案设计</title>
    <url>/2019/07/03/iOS-%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="先附上参考的文章："><a href="#先附上参考的文章：" class="headerlink" title="先附上参考的文章："></a>先附上参考的文章：</h4><p><a href="https://www.jianshu.com/p/69ce01e15042">iOS无埋点数据SDK实践之路</a><br><a href="https://www.jianshu.com/p/a6afc6252965">iOS无埋点数据统计实践</a></p>
<h4 id="该方案的统计功能？"><a href="#该方案的统计功能？" class="headerlink" title="该方案的统计功能？"></a>该方案的统计功能？</h4><ul>
<li>APP进入前台</li>
<li>按钮点击 （点击次数、按钮名称、点击方法）</li>
<li>cell点击</li>
<li>界面停留时长</li>
<li>APP进入后台</li>
</ul>
<h4 id="如何实现无埋点"><a href="#如何实现无埋点" class="headerlink" title="如何实现无埋点"></a>如何实现无埋点</h4><p>利用运行时机制，将类原生方法替换成用户自定义的方法，相当于强行在原本调用栈中插入一个方法，我们在其中插入一段统计代码即可。</p>
<span id="more"></span>
<h5 id="如何替换方法-Method-Swizzling"><a href="#如何替换方法-Method-Swizzling" class="headerlink" title="如何替换方法:Method Swizzling"></a>如何替换方法:Method Swizzling</h5><p>函数的调用涉及到3个重要的点：Class、SEL、IMP，Calss作为类型，Method由SEL和IMP组成。我们通过交换Method的IMP达到替换被调用函数的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心方法：</span><br><span class="line">- (void)sel_exchangeFirstSel:(SEL)sel1 secondSel:(SEL)sel2 &#123;</span><br><span class="line">    [self sel_exchangeClass:[self class] FirstSel:sel1 secondSel:sel2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sel_exchangeClass:(Class)Class FirstSel:(SEL)sel1 secondSel:(SEL)sel2 &#123;</span><br><span class="line">    Method firstMethod = class_getInstanceMethod(Class, sel1);</span><br><span class="line">    Method secondMethod = class_getInstanceMethod(Class, sel2);</span><br><span class="line">    method_exchangeImplementations(firstMethod, secondMethod);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>注：</strong></em> 这里主要交换的方法</p>
<table>
<thead>
<tr>
<th align="center">系统类</th>
<th align="center">类方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UIControl</td>
<td align="center">sendAction:to:forEvent</td>
</tr>
<tr>
<td align="center">UIGestureRecognizer</td>
<td align="center">addTarget:action:</td>
</tr>
<tr>
<td align="center">initWithTarget:action:</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">UIView</td>
<td align="center">addGestureRecognizer</td>
</tr>
<tr>
<td align="center">UITableView</td>
<td align="center">setDelegate</td>
</tr>
<tr>
<td align="center">tableView:didSelectRowAtIndexPath:</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">NSNotificationCenter</td>
<td align="center">postNotification</td>
</tr>
<tr>
<td align="center">postNotificationName:object:userInfo:</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">UIViewController</td>
<td align="center">viewDidAppear:</td>
</tr>
<tr>
<td align="center">viewDidDisappear:</td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="swizzling函数的时机"><a href="#swizzling函数的时机" class="headerlink" title="swizzling函数的时机"></a>swizzling函数的时机</h5><p>+(void)load函数在你动态加载或者静态引用了这个类的时候，该函数就会被执行，它并不需要你显示的去创建一个类后才会执行，同时它只会执行一次，几乎是完美的swizzling时机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例 UIControl</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        //创建新的sendAction:to:forEvent:方法</span><br><span class="line">        [self sel_exchangeFirstSel:@selector(sendAction:to:forEvent:) secondSel:@selector(ch_sendAction:to:forEvent:)];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="加入数据统计代码"><a href="#加入数据统计代码" class="headerlink" title="加入数据统计代码"></a>加入数据统计代码</h5><p>在swizzling成功后，我们在其中加入统计代码。为了保证响应链的完整，我们还需要调用替换过的方法，让事件传递下去，不去影响系统的处理。</p>
<ul>
<li>这里采用 <code>内联函数</code> 将该方法包起来使用 用于过滤黑名单（不参与统计的控制器）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 黑名单 不需要追踪的控制器 */</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">UIKIT_STATIC_INLINE BOOL kShouldTrackClass(Class aClass)&#123;</span><br><span class="line">    static NSSet *blacklistedClasses = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">//        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;BlackListed&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">//        NSArray *blacklistedClassNames = [NSArray arrayWithContentsOfFile:path];</span><br><span class="line">        </span><br><span class="line">        NSArray *blacklistedClassNames = [LogDAO sharedInstance].blackListArray;</span><br><span class="line">        NSMutableSet *transformedClasses = [NSMutableSet setWithCapacity:blacklistedClassNames.count];</span><br><span class="line">        for (NSString *className in blacklistedClassNames) &#123;</span><br><span class="line">            [transformedClasses addObject:NSClassFromString(className)];</span><br><span class="line">        &#125;</span><br><span class="line">        blacklistedClasses = [transformedClasses copy];</span><br><span class="line">    &#125;);</span><br><span class="line">    return ![blacklistedClasses containsObject:aClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="统计方式：操作数据库"><a href="#统计方式：操作数据库" class="headerlink" title="统计方式：操作数据库"></a>统计方式：操作数据库</h5><ul>
<li>数据库地址：<code>/var/mobile/Containers/Data/Application/······/Library/Caches/TheOnlineTax/Database/log.sqlite</code></li>
<li>数据库表名为 <code>info_log</code></li>
<li>表中的参数 也是模型中的属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, LogType) &#123;</span><br><span class="line">    LogTypeNone = 0,    // 未知</span><br><span class="line">    LogTypeLaunch,      // app 启动或前台</span><br><span class="line">    LogTypeButtonClick, // 按钮点击</span><br><span class="line">    LogTypeCellClick,   // cell点击</span><br><span class="line">    LogTypeVCRemainTime,// 界面停留时间</span><br><span class="line">    LogTypeTerminated,  // app 终止或后台</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *vc_id;// 控制器名称 </span><br><span class="line">@property (nonatomic) NSTimeInterval remainTime; //停留时间</span><br><span class="line">@property (nonatomic, copy) NSString *btn_id;// 按钮名称</span><br><span class="line">@property (nonatomic, copy) NSString *functionName;// 方法名称</span><br><span class="line">@property (nonatomic, assign) NSInteger num;// 点击次数</span><br><span class="line">@property (nonatomic) NSTimeInterval lastTime; //最后执行时间</span><br><span class="line">@property (nonatomic, assign) LogType logType; //记录类型</span><br></pre></td></tr></table></figure>

<ul>
<li>插入之前会判断是否存在 若存在只更新表</li>
<li>按钮次数 是通过 vc_id 和 btn_id 进行查表 累加所得</li>
<li>具体逻辑可看LogDAO文件</li>
</ul>
<h5 id="数据上传服务器"><a href="#数据上传服务器" class="headerlink" title="数据上传服务器"></a>数据上传服务器</h5><p>因没有后台存储这些统计出来的数据，暂时使用后端云Bmob存储</p>
<ul>
<li>触发上传的时机</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目前设计 (上传成功数据库的表里数据清空)</span><br><span class="line">1.是APP进入后台自动触发触发 </span><br><span class="line">2.用户退出登录操作触发</span><br></pre></td></tr></table></figure>
<ul>
<li>上传的拼接数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *userID = @&quot;0&quot;;//必须默认0</span><br><span class="line">    if ([AppDelegate trackGetUserID].length&gt;0) &#123;</span><br><span class="line">        userID = [AppDelegate trackGetUserID];</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dic = @&#123;</span><br><span class="line">                          //模型数组转成字典数组</span><br><span class="line">                          @&quot;list&quot; : [LogDTO mj_keyValuesArrayWithObjectArray:[[LogDAO sharedInstance] getAllData]],</span><br><span class="line">                          //应用名称</span><br><span class="line">                          @&quot;productName&quot; : kDisplayName,</span><br><span class="line">                          //bundleId</span><br><span class="line">                          @&quot;productID&quot; : [[NSBundle mainBundle] bundleIdentifier],</span><br><span class="line">                          //应用版本号</span><br><span class="line">                          @&quot;version&quot; : kVersion,</span><br><span class="line">                          //设备版本</span><br><span class="line">                          @&quot;osVersion&quot; : [NSString stringWithFormat:@&quot;%.1f&quot;,[DeviceAndSystemTool systemVersion]],</span><br><span class="line">                          //设备机型</span><br><span class="line">                          @&quot;osDeviceType&quot; : KStringIsEmpty([DeviceAndSystemTool getDeviceName]),</span><br><span class="line">                          //网络类型</span><br><span class="line">                          @&quot;networkType&quot; : KStringIsEmpty([DeviceAndSystemTool networkTypeName]),</span><br><span class="line">                          //运营商</span><br><span class="line">                          @&quot;isp&quot; : KStringIsEmpty([DeviceAndSystemTool wsd_telephonyNetworkInfo]),</span><br><span class="line">                          //定位（省市区）</span><br><span class="line">                          @&quot;gps&quot; : KStringIsEmpty(self.strLocationInfo)</span><br><span class="line">                          &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>APP启动会先获取服务器的数据 若有只在原有基础上更新不会新增一条数据（改动是TrackData和updateAT字段）会根据UserID字段区分数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 新增一条数据 */</span><br><span class="line"></span><br><span class="line">    BmobObject *trackBmob = [BmobObject objectWithClassName:@&quot;TrackAction&quot;];</span><br><span class="line">    [trackBmob setObject:dic forKey:@&quot;TrackData&quot;];</span><br><span class="line">    [trackBmob setObject:[AppDelegate trackGetUserID] forKey:@&quot;UserID&quot;];</span><br><span class="line">    [trackBmob saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) &#123;</span><br><span class="line">        //进行操作</span><br><span class="line">        if (isSuccessful) &#123;</span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(YES,nil);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(NO,error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 更新一条数据 */</span><br><span class="line"></span><br><span class="line">//创建查表对象</span><br><span class="line">    BmobQuery   *bquery = [BmobQuery queryWithClassName:@&quot;TrackAction&quot;];</span><br><span class="line">    //设置查询中该字段是有值的结果</span><br><span class="line">    [bquery whereKeyExists:@&quot;UserID&quot;];</span><br><span class="line">    //设置查询中该字段 值是否相等的结果</span><br><span class="line">    [bquery whereKey:@&quot;UserID&quot; equalTo:[AppDelegate trackGetUserID]];</span><br><span class="line">    //查询</span><br><span class="line">    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) &#123;</span><br><span class="line">        if (error)&#123;</span><br><span class="line">            //进行错误处理</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if (array) &#123;</span><br><span class="line">                BmobObject *obj = array[0];</span><br><span class="line"></span><br><span class="line">                NSString *userID = @&quot;0&quot;;//必须默认0</span><br><span class="line">                if ([AppDelegate trackGetUserID].length&gt;0) &#123;</span><br><span class="line">                    userID = [AppDelegate trackGetUserID];</span><br><span class="line">                &#125;</span><br><span class="line">                NSDictionary *dic = @&#123;</span><br><span class="line">                                      //模型数组转成字典数组</span><br><span class="line">                                      @&quot;list&quot; : [LogDTO mj_keyValuesArrayWithObjectArray:[[LogDAO sharedInstance] getAllData]],</span><br><span class="line">                                      //userid</span><br><span class="line">                                      @&quot;userid&quot; : KStringIsEmpty(userID),</span><br><span class="line">                                      //应用名称</span><br><span class="line">                                      @&quot;productName&quot; : kDisplayName,</span><br><span class="line">                                      //bundleId</span><br><span class="line">                                      @&quot;productID&quot; : [[NSBundle mainBundle] bundleIdentifier],</span><br><span class="line">                                      //应用版本号</span><br><span class="line">                                      @&quot;version&quot; : kVersion,</span><br><span class="line">                                      //设备版本</span><br><span class="line">                                      @&quot;osVersion&quot; : [NSString stringWithFormat:@&quot;%.1f&quot;,[DeviceAndSystemTool systemVersion]],</span><br><span class="line">                                      //设备机型</span><br><span class="line">                                      @&quot;osDeviceType&quot; : KStringIsEmpty([DeviceAndSystemTool getDeviceName]),</span><br><span class="line">                                      //网络类型</span><br><span class="line">                                      @&quot;networkType&quot; : KStringIsEmpty([DeviceAndSystemTool networkTypeName]),</span><br><span class="line">                                      //运营商</span><br><span class="line">                                      @&quot;isp&quot; : KStringIsEmpty([DeviceAndSystemTool wsd_telephonyNetworkInfo]),</span><br><span class="line">                                      //定位（省市区）</span><br><span class="line">                                      @&quot;gps&quot; : KStringIsEmpty(self.strLocationInfo)</span><br><span class="line">                                      &#125;;</span><br><span class="line"></span><br><span class="line">                BmobObject *obj1 = [BmobObject objectWithoutDataWithClassName:obj.className objectId:obj.objectId];</span><br><span class="line">                //设置cheatMode为YES</span><br><span class="line">                [obj1 setObject:dic forKey:@&quot;TrackData&quot;];</span><br><span class="line">                //异步更新数据</span><br><span class="line">                [obj1 updateInBackground];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<h4 id="引用方法："><a href="#引用方法：" class="headerlink" title="引用方法："></a>引用方法：</h4><p>目前没有集成到pod上 只能手动导入 这是相关文件：<a href="https://github.com/NickChenHao/TrackAction.git">GitHub</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【 使用说明 】</span><br><span class="line"> 1.需要依赖 pod &#x27;MJExtension&#x27; 和 pod &#x27;AFNetworking&#x27; 请确保项目中已有</span><br><span class="line"> 2.将文件拖入项目中</span><br><span class="line"> 3.需在pch文件中引用  #import &quot;TrackAction.h&quot;</span><br><span class="line"> 4.需在AppDelegate.m文件中</span><br><span class="line">   a.调用 createTablesNeeded 创建数据库</span><br><span class="line">   b.重写 trackGetUserID     配置userID</span><br><span class="line">   c.重写 trackServiceURL    配置上传服务器的地址</span><br><span class="line"> 5.可添加不需要统计的控制器在BlackListed.plist</span><br></pre></td></tr></table></figure>

<h4 id="更新部分【重要】"><a href="#更新部分【重要】" class="headerlink" title="更新部分【重要】"></a>更新部分【重要】</h4><h5 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a><del>引用方法</del></h5><ul>
<li>手动导入 这是相关文件：<a href="https://github.com/NickChenHao/TrackAction.git">GitHub</a></li>
<li>引用svn私有库 <code>pod &#39;ASTrackAction&#39;,&#39;1.0.0&#39;</code></li>
</ul>
<h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a><del>使用说明</del></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【 使用说明 】</span><br><span class="line"> 1.依赖 pod &#x27;MJExtension&#x27; 和 pod &#x27;AFNetworking&#x27;</span><br><span class="line"> 2.需在pch文件中引用  #import &quot;TrackAction.h&quot;</span><br><span class="line"> 3.需在AppDelegate里的方法实现 配置track信息的方法 在LogDAO类中 （不开启埋点功能 注释即可）</span><br></pre></td></tr></table></figure>
<h5 id="上传的拼接数据"><a href="#上传的拼接数据" class="headerlink" title="上传的拼接数据"></a><del>上传的拼接数据</del></h5><p>修改为<br>1.先判断是开启埋点功能<br>2.再判断是否自定义服务器地址 若有则AFN请求 若无则上传至Bmob后端云</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    if (!self.isOpenTracker) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *userID = @&quot;0&quot;;//必须默认0</span><br><span class="line">    if (self.userId.length&gt;0) &#123;</span><br><span class="line">        userID = self.userId;</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dic = @&#123;</span><br><span class="line">                          //模型数组转成字典数组</span><br><span class="line">                          @&quot;list&quot; : [LogDTO mj_keyValuesArrayWithObjectArray:[[LogDAO sharedInstance] getAllData]],</span><br><span class="line">                          //userid</span><br><span class="line">                          @&quot;userid&quot; : KStringIsEmpty(userID),</span><br><span class="line">                          //应用名称</span><br><span class="line">                          @&quot;productName&quot; : kDisplayName,</span><br><span class="line">                          //bundleId</span><br><span class="line">                          @&quot;productID&quot; : [[NSBundle mainBundle] bundleIdentifier],</span><br><span class="line">                          //应用版本号</span><br><span class="line">                          @&quot;version&quot; : kVersion,</span><br><span class="line">                          //设备版本</span><br><span class="line">                          @&quot;osVersion&quot; : [NSString stringWithFormat:@&quot;%.1f&quot;,[DeviceAndSystemTool systemVersion]],</span><br><span class="line">                          //设备机型</span><br><span class="line">                          @&quot;osDeviceType&quot; : KStringIsEmpty([DeviceAndSystemTool getDeviceName]),</span><br><span class="line">                          //网络类型</span><br><span class="line">                          @&quot;networkType&quot; : KStringIsEmpty([DeviceAndSystemTool networkTypeName]),</span><br><span class="line">                          //运营商</span><br><span class="line">                          @&quot;isp&quot; : KStringIsEmpty([DeviceAndSystemTool wsd_telephonyNetworkInfo]),</span><br><span class="line">                          //定位（省市区）</span><br><span class="line">                          @&quot;gps&quot; : KStringIsEmpty(self.strLocationInfo)</span><br><span class="line">                          &#125;;</span><br><span class="line"></span><br><span class="line">    if (!ISEMPTY(self.serviceURL)) &#123;</span><br><span class="line">#pragma mark - AFN</span><br><span class="line"></span><br><span class="line">        [TrackActionServiceManager postParameter:dic Success:^(NSURLSessionDataTask *operation, id responseObject) &#123;</span><br><span class="line"></span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(YES,nil);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; Failure:^(NSURLSessionDataTask *operation, NSError *error) &#123;</span><br><span class="line"></span><br><span class="line">            if (handler) &#123;</span><br><span class="line">                handler(NO,error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">#pragma mark - 后端云SDK</span><br><span class="line"></span><br><span class="line">        BmobObject *trackBmob = [BmobObject objectWithClassName:@&quot;TrackAction&quot;];</span><br><span class="line">        [trackBmob setObject:dic forKey:@&quot;TrackData&quot;];</span><br><span class="line">        [trackBmob setObject:self.userId forKey:@&quot;UserID&quot;];</span><br><span class="line">        [trackBmob saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) &#123;</span><br><span class="line">            //进行操作</span><br><span class="line">            if (isSuccessful) &#123;</span><br><span class="line">                if (handler) &#123;</span><br><span class="line">                    handler(YES,nil);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if (handler) &#123;</span><br><span class="line">                    handler(NO,error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>swift笔记1</title>
    <url>/2016/01/25/swift/</url>
    <content><![CDATA[<h2 id="Swift最基本的语法变化"><a href="#Swift最基本的语法变化" class="headerlink" title="Swift最基本的语法变化"></a>Swift最基本的语法变化</h2><ul>
<li><p>导入框架 import UIKit</p>
</li>
<li><p>定义标识符时，必须声明该标识符是变量还是常量声明标识符的<br>格式:变量&#x2F;常量关键字 名称 : 数据类型</p>
</li>
<li><p>语句结束时不需要加 ;如果同一行有多个语句,则依然需要加<br>但是不建议一行多条语句</p>
</li>
<li><p>Swift中的打印语句: print(“打印的内容”)</p>
<span id="more"></span></li>
</ul>
<h2 id="什么是常量和变量"><a href="#什么是常量和变量" class="headerlink" title="什么是常量和变量"></a>什么是常量和变量</h2><ul>
<li>在Swift中规定:在定义一个标识符时必须明确说明该标识符是一个常量还是变量<br>1.使用let来定义常量,定义之后不可以修改<br>2.使用var来定义变量,定义之后可以修改</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>在真实使用过程中,建议先定义常量,如果需要修改再修改为变量(更加安全)<br>是指向的对象不可以再进行修改.但是可以通过指针获得对象后,修改对象内部的属性</p>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>Swift是强类型的语言<br>Swift中任何一个标识符都有明确的类型</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h4><p>1.如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.<br>2.因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型 可以通过option+鼠标左键 来查看变量的数据类型 </p>
<h2 id="Swift中基本运算"><a href="#Swift中基本运算" class="headerlink" title="Swift中基本运算"></a>Swift中基本运算</h2><p>1.Swift中在进行基本运算时必须保证类型一致,否则会出错相同类型之间才可以进行运算<br>因为Swift中没有隐式转换</p>
<p>2.数据类型的转化Int类型转成Double类型:Double(标识符)<br>Double类型转成Int类型:Int(标识符)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 10</span><br><span class="line">let b = 3.14</span><br><span class="line">// 错误写法 </span><br><span class="line">//let c = a + b </span><br><span class="line">//let c = a * b</span><br><span class="line">// 正确写法</span><br><span class="line">let c = Double(a) + blet </span><br><span class="line">d = a + Int(b)</span><br></pre></td></tr></table></figure>

<p>if分支语句<br>和OC中if语句有一定的区别判断句可以不加()<br>在Swift的判断句中必须有明确的真假不再有非0即真<br>必须有明确的Bool值<br>Bool有两个取值:false&#x2F;true</p>
<h2 id="guard的使用"><a href="#guard的使用" class="headerlink" title="guard的使用"></a>guard的使用</h2><p>guard语句必须带有else语句，它的语法如下：当条件表达式为true时候跳过else语句中的内容，执行语句组内容<br>条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guard 条件表达式 else &#123;  // 条换语句 </span><br><span class="line">  break&#125;</span><br><span class="line">语句组</span><br></pre></td></tr></table></figure>
<h2 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h2><p>基本用法和OC用法一致<br>不同之处:switch后可以不跟()<br>case后可以不跟break(默认会有break)</p>
<h4 id="简单使用补充"><a href="#简单使用补充" class="headerlink" title="简单使用补充:"></a>简单使用补充:</h4><p>1.一个case判断中,可以判断多个值<br>多个值以, 隔开 如果希望出现之前的case穿透,则可以使用关键字fallthrough</p>
<p>2.什么是区间?通常我们指的是数字区间:0<del>10,100</del>200</p>
<p>3.swift中的区间常见有两种半开半闭区间:0..&lt;10 表示:0<del>9,不包括10<br>闭区间:0…10 表示:0</del>10</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let score = 88switch score &#123;</span><br><span class="line">    case 0..&lt;60:    </span><br><span class="line">        print(&quot;不及格&quot;)</span><br><span class="line">    case 60..&lt;80:    </span><br><span class="line">        print(&quot;几个&quot;)</span><br><span class="line">    case 80..&lt;90:    </span><br><span class="line">        print(&quot;良好&quot;)</span><br><span class="line">    case 90..&lt;100:    </span><br><span class="line">        print(&quot;优秀&quot;)</span><br><span class="line">    default:   </span><br><span class="line">        print(&quot;满分&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环的介绍"><a href="#循环的介绍" class="headerlink" title="循环的介绍"></a>循环的介绍</h2><ul>
<li>在开发中经常会需要循环</li>
<li>常见的循环有:for&#x2F;while&#x2F;do while.</li>
<li>这里我们只介绍for&#x2F;while,因为for&#x2F;while最常见</li>
</ul>
<h2 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h2><ul>
<li>最常规写法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">for var i = 0; i &lt; 10; i++ &#123; </span><br><span class="line">     print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>区间for循环</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//半开半闭区间</span><br><span class="line">for i in 0..&lt;10 &#123; </span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">//闭区间</span><br><span class="line">for i in 0...10 &#123; </span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特殊写法如果在for循环中不需要用到下标i</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for _ in 0..&lt;10 &#123; </span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while和do-while循环"><a href="#while和do-while循环" class="headerlink" title="while和do while循环"></a>while和do while循环</h2><ul>
<li>while循环</li>
<li>while的判断句必须有正确的真假,没有非0即真</li>
<li>while后面的()可以省略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">while a &lt; 10 &#123; </span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>do while循环使用</li>
<li>repeat关键字来代替了do</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let b = 0</span><br><span class="line">repeat &#123; </span><br><span class="line">    print(b)</span><br><span class="line">    b++</span><br><span class="line">&#125; while b &lt; 20</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>swift笔记2</title>
    <url>/2016/01/26/swift%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="字符串的介绍"><a href="#字符串的介绍" class="headerlink" title="字符串的介绍"></a>字符串的介绍</h3><ul>
<li>字符串在任何的开发中使用都是非常频繁的</li>
<li>OC和Swift中字符串的区别</li>
<li>在OC中字符串类型时NSString,在Swift中字符串类型是String</li>
<li>OC中字符串@””,Swift中字符串””</li>
<li>使用 String 的原因</li>
<li>String 是一个结构体，性能更高</li>
<li>NSString 是一个 OC 对象，性能略差</li>
<li>String 支持直接遍历</li>
<li>Swift 提供了 String 和 NSString 之间的无缝转换</li>
</ul>
 <span id="more"></span>
<h3 id="字符的定义"><a href="#字符的定义" class="headerlink" title="字符的定义"></a>字符的定义</h3><ul>
<li><p>定义不可变字符串<br><code>let str = &quot;hello Objective-C&quot;</code></p>
</li>
<li><p>定义可变字符串<br><code>var str = &quot;hello Swift&quot;</code></p>
</li>
</ul>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p>获取字符串的长度</p>
<ul>
<li><p>获取字符集合,再获取集合的count属性<br><code>let count = str.characters.count</code></p>
</li>
<li><p>遍历字符串</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;Hello, Swift&quot;</span><br><span class="line">for c in str.characters &#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li>两个字符串的拼接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str1 = &quot;Hello&quot;</span><br><span class="line">let str2 = &quot;World&quot;</span><br><span class="line">let str3 = str1 + str2</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串和其他数据类型的拼接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &quot;why&quot; </span><br><span class="line">let age = 18 </span><br><span class="line">let info = &quot;my name is \(name), age is \(age)&quot; </span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的格式化</li>
<li>比如时间:03:04</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let min = 3</span><br><span class="line">let second = 4</span><br><span class="line">let time = String(format: &quot;%02d:%02d&quot;, arguments: [min, second])</span><br></pre></td></tr></table></figure>

<p>###字符串的截取</p>
<ul>
<li>Swift中提供了特殊的截取方式</li>
<li>该方式非常麻烦</li>
<li>Index创建较为麻烦</li>
<li>简单的方式是将String转成NSString来使用</li>
<li>在标识符后加:as NSString即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myStr = &quot;www.520it.com&quot;</span><br><span class="line">var subStr = (myStr as NSString).substringFromIndex(4)</span><br><span class="line">subStr = (myStr as NSString).substringToIndex(3)</span><br><span class="line">subStr = (myStr as NSString).substringWithRange(NSRange(location: 4, length: 5))</span><br></pre></td></tr></table></figure>
<ul>
<li>swift截取方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义字符串</span><br><span class="line">let str = &quot;www.520it.com&quot;</span><br><span class="line"></span><br><span class="line">// 2.截取开始位置</span><br><span class="line">let fromIndex = str.startIndex.advancedBy(3)</span><br><span class="line">let header = str.substringFromIndex(fromIndex)</span><br><span class="line"></span><br><span class="line">// 3.截取结束位置</span><br><span class="line">let toIndex = str.endIndex.advancedBy(-3)</span><br><span class="line">let footer = str.substringToIndex(toIndex)</span><br><span class="line"></span><br><span class="line">// 4.截取中间的字符串</span><br><span class="line">let range = Range(start: str.startIndex.advancedBy(4), end: str.endIndex.advancedBy(-4))</span><br><span class="line">let middle = str.substringWithRange(range)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>tableView的性能优化</title>
    <url>/2016/06/02/tableView%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="tableView性能优化"><a href="#tableView性能优化" class="headerlink" title="tableView性能优化"></a>tableView性能优化</h3><p>tableview的优化一直是一个很考验基本功的活儿，之前做项目的适合被这个问题困扰了很久，通过性能工具、查阅文档解决，整理思路和解决方案如下：</p>
<h4 id="tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。"><a href="#tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。" class="headerlink" title="tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。"></a>tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。</h4><ul>
<li>cell是否使用了复用机制而不是每一次都创建新的cell。</li>
</ul>
<p>如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。</p>
<span id="more"></span>
<ul>
<li>cell是否添加了大量的子控件，或者对layer做了过多的操作。</li>
</ul>
<p>如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。</p>
<ul>
<li>高度计算方法时不做复杂的计算，尽量只使用加减乘除。</li>
</ul>
<p>自适应高度的cell实现方式有很多种，比如，</p>
<p>1.使用iOS7以上系统的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat</span><br></pre></td></tr></table></figure>
<p>这个方法中，可以先给一个估计的高度，系统会从你给定的高度再去计算实际高度。但是在使用过程中会出现cell突然变高变得低的情况，不适用于高度变化太大的cell。</p>
<p>2.如果使用约束布局创建的cell子控件，子控件之间都建立了相互约束，最上面的子控件与cell顶部建立约束，最下面的子控件与cell底部建立了约束，相当于子控件把cell撑开了。</p>
<p>约束简图:<br><img src="/Users/nick/Desktop/1.jpeg"></p>
<p>这时在高度计算方法中，走一遍cell的loaddata方法后可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func systemLayoutSizeFittingSize(targetSize: CGSize) -&gt; CGSize</span><br></pre></td></tr></table></figure>
<p>取得cell的size，进而得到cell高度。<br>通过这个方法获取的cell高度是十分精确的，只要创建好子控件的约束就能获得cell的size。比较不好的是只是这种方法会重走一遍cell的loaddata方法。除此之外在调用cell的loaddata之前需要得到cell的实例，实例创建的方式应该与cellForRow方法一样，优先从缓存池中取得。<br>这个方案可能会创建多个cell。如果能在内存汇总保存一份cell的实例就能解决这个问题了！我讲讲我实现的思路：<br>首先先注册cell,当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回给你。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override func viewDidLodad() &#123;</span><br><span class="line">    tableView.registerClass(CardCell.self, forCellReuseIdentifier: ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用lazy创建一个cell实例，由于lazy 关键字，cell的创建只会执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazy var cell:CardCell = &#123;</span><br><span class="line">      //已经注册过cell，当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回</span><br><span class="line">      let v = self.myTableView?.dequeueReusableCellWithIdentifier(self.ID) as! CardCell</span><br><span class="line">      return v</span><br><span class="line">      &#125;()</span><br></pre></td></tr></table></figure>
<p>通过懒加载的方式，只创建一次cell的实例，避免内存浪费。<br>接下来要做的步骤就是之前讲的，调用cell的loadData方法，计算高度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</span><br><span class="line">  self.imageCell.loadData(d)    </span><br><span class="line">  let height:CGFloat = self.cell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize).height</span><br><span class="line">return height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="之前查资料的时候还有用空间换取时间的方案："><a href="#之前查资料的时候还有用空间换取时间的方案：" class="headerlink" title="之前查资料的时候还有用空间换取时间的方案："></a>之前查资料的时候还有用空间换取时间的方案：</h4><p>1）在请求网络数据成功后就计算好高度并通过字典或者数组保存高度值，在高度方法中直接根据数组下标或者key值取得高度并返回。</p>
<p>2）还有建立一个frameModel的方法，与1中相似，只是获得网络数据后保存到frameModel中，在frameModel中定义一个类方法，通过获得的model值计算高度后返回。<br>避免快速滑动情况下开过多线程。<br>cell中的图片开线程异步加载，相信每个人都会想到。线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">      var canLoad:Bool = !tableView.dragging &amp;&amp; !tableView.declearating</span><br><span class="line">      if  canLoad &#123;</span><br><span class="line">          //开始loaddata，异步加载图片</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图片处理</li>
</ul>
<p>1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。<br>2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示<br>3）避免对layer做过多的操作，尽量设置图片为不透明</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><ul>
<li>简单的设置cornerRadius是不会影响性能的，但是设置了maskToBounds，会导致离屏渲染，应减少设置图层 maskToBounds &#x3D; YES ，；</li>
<li>使用懒加载图片的方式避免重复下载图片，浪费资源。图片下载后并做压缩处理后将其保存到缓存中，下次加载此图片之前先从缓存中取，如果取不到该图片就在后台下载保存。</li>
<li>使用Core Graphics实现圆角等功能。</li>
<li>重写drawRect方法会离屏渲染，导致内存急剧上升，即使在这个方法里面不写一句代码，也会让内存升高。</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>原生集成code-push热更新RN功能</title>
    <url>/2019/08/16/%E5%8E%9F%E7%94%9F%E9%9B%86%E6%88%90codePush%E7%83%AD%E6%9B%B4%E6%96%B0RN%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>code-push是一个微软开发的云服务器。通过它，开发者可以直接在用户的设备上部署手机应用更新。code-push相当于一个中心仓库，开发者可以推送当前的更新（包括JS&#x2F;HTML&#x2F;CSS&#x2F;IMAGE等）到code-push，然后应用将会查询是否有更新。<br>虽然苹果禁了很多热更新，但是，code-push 还是可以用的。项目是 ReactNative 的，总结了下 iOS 的 code-push 的使用方法。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/6a5e00d22723">code-push热更新详细接入教程</a><br><a href="https://www.jianshu.com/p/6bbb8020c29e">code-push热更新配置（命令整理）</a></p>
<span id="more"></span>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="安装code-push-cli"><a href="#安装code-push-cli" class="headerlink" title="安装code-push-cli"></a>安装code-push-cli</h4><p>安装code-push指令，直接在终端上输入如下命令即可，注意：这个code-push指令只需要全局安装一次即可，如果第一次安装成功了，那后面就不在需要安装<br><code>npm install -g code-push-cli</code></p>
<h4 id="注册code-push账号"><a href="#注册code-push账号" class="headerlink" title="注册code-push账号"></a>注册code-push账号</h4><ul>
<li>注册code-push账号也很简单，同样是只需简单的执行下面的命令，同样这个注册操作也是全局只需要注册一次即可<code>code-push register</code></li>
<li>当执行完上面的命令后，会自动打开一个授权网页，让你选择使用哪种方式进行授权登录，这里我们统一就选择使用GitHub即可</li>
<li>当注册成功后，code-push会给我们一个key</li>
<li>我们直接复制这个key，然后在终端中将这个key填写进去即可</li>
<li>验证是否登录成功 <code>code-push login</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code-push注册登录相关命令：</span><br><span class="line">	•	code-push login 登陆</span><br><span class="line">	•	code-push loout 注销</span><br><span class="line">	•	code-push access-key ls 列出登陆的token</span><br><span class="line">	•	code-push access-key rm &lt;accessKye&gt; 删除某个 access-key</span><br></pre></td></tr></table></figure>
<h4 id="在code-push服务器注册App"><a href="#在code-push服务器注册App" class="headerlink" title="在code-push服务器注册App"></a>在code-push服务器注册App</h4><p><code> code-push app add 项目名称 ios react-native</code><br>可以查看添加的App列表<br><code>code-push app list</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code-push管理App的相关命令：</span><br><span class="line">	•	code-push app add 在账号里面添加一个新的app</span><br><span class="line">	•	code-push app remove 或者 rm 在账号里移除一个app</span><br><span class="line">	•	code-push app rename 重命名一个存在app</span><br><span class="line">	•	code-push app list 或则 ls 列出账号下面的所有app</span><br><span class="line">	•	code-push app transfer 把app的所有权转移到另外一个账号</span><br></pre></td></tr></table></figure>

<h4 id="RN代码中集成code-push-不熟悉先省略"><a href="#RN代码中集成code-push-不熟悉先省略" class="headerlink" title="RN代码中集成code-push (不熟悉先省略)"></a>RN代码中集成code-push (不熟悉先省略)</h4><h4 id="原生应用中配置code-push"><a href="#原生应用中配置code-push" class="headerlink" title="原生应用中配置code-push"></a>原生应用中配置code-push</h4><ul>
<li>   使用Xcode打开项目，Xcode的项目导航视图中的PROJECT下选择你的项目，选择Info页签 ，在Configurations节点下单击 + 按钮 ，选择Duplicate “Release Configaration，输入Staging</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-fbfc9b79199d4a3f..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<ul>
<li>选择Build Settings tab，搜索Build Location -&gt; Per-configuration Build Products Path -&gt; Staging，将之前的值：<code>$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)</code> 改为：<code>$(BUILD_DIR)/Release$(EFFECTIVE_PLATFORM_NAME)</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-369c31244b0f528f..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<ul>
<li>选择Build Settings tab，点击 + 号，选择Add User-Defined Setting，将key设置为<code>CODEPUSH_KEY</code>，Release 和 Staging的值为前面创建的key，我们直接复制进去即可</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-663dc2df47438cc5..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<ul>
<li><pre><code>•	打开Info.plist文件，在`CodePushDeploymentKey`中输入`$(CODEPUSH_KEY)`，并修改`Bundle versions string,short`为三位
</code></pre>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6342050-c4392091edc647a0..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="avatar"></p>
<h4 id="打包RN离线的jsbundle"><a href="#打包RN离线的jsbundle" class="headerlink" title="打包RN离线的jsbundle"></a>打包RN离线的jsbundle</h4><ol>
<li><p>在package.json根目录创建文件夹relseae_ios， 执行如下命令打包成index.bundle<br><code>react-native bundle --entry-file index.js --platform ios --dev false --bundle-output relseae_ios/index.bundle --assets-dest relseae_ios</code></p>
</li>
<li><p>将index.bundle拷贝到当前目录<br><code>cp ./relseae_ios/index.bundle ./</code></p>
</li>
<li><p>开启本地服务，生成jsbundle<br>在根目录执行npm start<br>Ctrl+T 开启新窗口（确保在pakage.json根目录）<br>执行命令  <code>curl &#39;http://localhost:8081/index.bundle?dev=false&amp;minify=true&amp;platform=ios&#39; -o main.jsbundle</code></p>
</li>
<li><p>将main.jsbundle复制到relseae_ios目录下<br><code>cp ./main.jsbundle ./relseae_ios</code></p>
</li>
<li><p>将根目录里的<code>main.jsbundle</code>和<code>relseae_ios目录下的资源文件</code>拖拽至工程下 </p>
</li>
<li><p>设置Bundle离线包路径<br><code>jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</code></p>
</li>
</ol>
<h4 id="发布RN更新jsbundle版本"><a href="#发布RN更新jsbundle版本" class="headerlink" title="发布RN更新jsbundle版本"></a>发布RN更新jsbundle版本</h4><ul>
<li><p>原生AppDelegete里需要配置<br><code>jsCodeLocation = [CodePush bundleURL]; </code></p>
</li>
<li><p>更新jsbundle 要用以下命令 在项目根目录里<br><code>code-push release TheOnlineTax ./relseae_ios/ 3.5.5 --des &quot;还原RN代码” --m true —-d Production</code></p>
</li>
</ul>
<p><strong>注：</strong><br>强制更新 –m true<br>生产环境 –d Production </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名称    TheOnlineTax    </span><br><span class="line">文件路径    ./relseae_ios/  </span><br><span class="line">项目版本号  3.5.5           </span><br><span class="line">更新描述    &quot;还原RN代码”     </span><br></pre></td></tr></table></figure>
<ul>
<li>查看更新情况</li>
</ul>
<p>生成环境 <code>code-push deployment history 项目名称 Production</code><br>开发环境 <code>code-push deployment history 项目名称 Staging</code><br>或者 <code>code-push deployment ls 项目名称</code></p>
]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>热更新</tag>
      </tags>
  </entry>
  <entry>
    <title>发布过程的问题</title>
    <url>/2017/01/23/%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="发布时遇到的一些问题"><a href="#发布时遇到的一些问题" class="headerlink" title="发布时遇到的一些问题"></a>发布时遇到的一些问题</h3><h4 id="iOS10-之后需要添加info-plist文件配置"><a href="#iOS10-之后需要添加info-plist文件配置" class="headerlink" title="iOS10 之后需要添加info.plist文件配置:"></a>iOS10 之后需要添加info.plist文件配置:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开蓝牙可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开相机可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开通讯录可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开麦克风可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开相册可以吗？&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>若没有apple会发此邮箱:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This app attempts to access privacy-sensitive data without a usage description. The app&#x27;s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.</span><br><span class="line"></span><br><span class="line">This app attempts to access privacy-sensitive data without a usage description. The app&#x27;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.</span><br></pre></td></tr></table></figure>

<h4 id="报错"><a href="#报错" class="headerlink" title="报错:"></a>报错:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- ERROR ITMS-90474: &quot;Invalid Bundle. iPad Multitasking support requires these orientations: &#x27;UIInterfaceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown,UIInterfaceOrientationLandscapeLeft,UIInterfaceOrientationLandscapeRight&#x27;. Found &#x27;UIInterfaceOrientationPortrait&#x27; in bundle &#x27;xxxx&#x27;.&quot; </span><br><span class="line">- ERROR ITMS-90475: &quot;Invalid Bundle. iPad Multitasking support requires launch story board in bundle &#x27;xxxx’.&quot; </span><br></pre></td></tr></table></figure>
<p>解决方案:<br>打开项目属性，选择“General”选项，勾选红框标注的“Requires full screen”</p>
<h4 id="报错-1"><a href="#报错-1" class="headerlink" title="报错:"></a>报错:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR ITMS-90032:“Invalid Image Path - No image found at the path referenced under key &#x27;CFBundleIcons&#x27;:AppIcon40x40”</span><br></pre></td></tr></table></figure>
<p>解决方案:<br>图片的问题  缺少对应的图片尺寸 需要在图片资源文件的 appicon中添加</p>
<p><img src="/Users/nick/Desktop/Snip20170122_3.png"></p>
]]></content>
      <categories>
        <category>发布问题</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>学习数据建模</title>
    <url>/2020/02/13/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2020年年关，“新冠状病毒”感染所致的肺炎肆虐全国，成为了继2003年非典以来更严重的瘟疫。口罩是预防肺炎的有效手段之一，口罩的种类有多种，比如纱布口罩、医用口罩（如N95）、日用口罩、防尘口罩等，口罩的制作过程、工艺、样式大致相同，但使用对象会因为不同的使用场景而不同，比如普通民众和医生使用的口罩，室内生产线上的工人和场外工地上的工人使用的口罩。<br>口罩当前已成为了“硬通货”，堪比日常的油盐酱醋，全国各地都在加班加点生产，近日，富士康和比亚迪已宣布开始生产口罩。<br>请根据以上材料结合设计模式的相关知识对口罩进行建模？</p>
<span id="more"></span>

<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://blog.csdn.net/zhangchen2449/article/details/80530027">商品销售数据建模及分析</a><br><a href="https://blog.csdn.net/gao2175/article/details/90206739">3个问题带你入门数据建模</a><br><a href="https://www.iteye.com/blog/student-lp-2212743">数据仓库建设-数据建模</a><br><a href="http://www.itxm.cn/post/6976.html">数据建模详解</a></p>
<h3 id="模块目录"><a href="#模块目录" class="headerlink" title="模块目录"></a>模块目录</h3><ul>
<li><p><a href="#module-MASK-relation" title="关联关系"><h5 id="module-MASK-relation}-from">1. 关联关系</h5></a></p>
</li>
<li><p><a href="#module-MASK-tableList" title="表清单"><h5 id="module-MASK-tableList-from">2. 表清单</h5></a></p>
</li>
<li><p><a href="#module-MASK-tableColumnList" title="表列清单"><h5 id="module-MASK-tableColumnList-from">3. 表列清单</h5></a></p>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_KIND" title="MASK_KIND"><h6 id="module-MASK-tableColumnList-MASK_KIND-from">3.1 MASK_KIND【种类】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_STANDARD" title="MASK_STANDARD"><h6 id="module-MASK-tableColumnList-MASK_STANDARD-from">3.2 MASK_STANDARD【执行标准】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_FUNCTION" title="MASK_FUNCTION"><h6 id="module-MASK-tableColumnList-MASK_FUNCTION-from">3.3 MASK_FUNCTION【功能】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_COMPOSITIONS" title="MASK_COMPOSITIONS"><h6 id="module-MASK-tableColumnList-MASK_COMPOSITIONS-from">3.4 MASK_COMPOSITIONS【产品构成】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_USER" title="MASK_USER"><h6 id="module-MASK-tableColumnList-MASK_USER-from">3.5 MASK_USER【使用对象】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_RANGE" title="MASK_RANGE"><h6 id="module-MASK-tableColumnList-MASK_RANGE-from">3.6 MASK_RANGE【适用场景】</h6></a></li>
<li><a href="#module-MASK-tableColumnList-MASK_RISK" title="MASK_RISK"><h6 id="module-MASK-tableColumnList-MASK_RISK-from">3.7 MASK_RISK【风险等级】</h6></a></li>
</ul>
<hr>
</li>
</ul>
<h2 id="1-关联关系"><a href="#1-关联关系" class="headerlink" title="1.关联关系
 "></a><a href="#module-MASK-relation-from"><h5 id="module-MASK-relation">1.关联关系</h5></a>
 </h2><p><img src="/images/%E5%8F%A3%E7%BD%A9%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1.png" alt="MASK-关系图"></p>
<hr>
<p> <a href="#module-MASK-tableList-from"><h5 id="module-MASK-tableList">2.表清单</h5></a></p>
<hr>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>种类</td>
<td>MASK_KIND</td>
<td></td>
</tr>
<tr>
<td>执行标准</td>
<td>MASK_STANDARD</td>
<td></td>
</tr>
<tr>
<td>功能</td>
<td>MASK_FUNCTION</td>
<td></td>
</tr>
<tr>
<td>产品构成</td>
<td>MASK_COMPOSITIONS</td>
<td></td>
</tr>
<tr>
<td>使用对象</td>
<td>MASK_USER</td>
<td></td>
</tr>
<tr>
<td>适用场景</td>
<td>MASK_RANGE</td>
<td></td>
</tr>
<tr>
<td>风险等级</td>
<td>MASK_RISK</td>
<td></td>
</tr>
</tbody></table>
<hr>
<p> <a href="#module-MASK-tableColumnList-from"><h5 id="module-MASK-tableColumnList">3.表列清单</h5></a></p>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_KIND-from"><h6 id="module-MASK-tableColumnList-MASK_KIND">MASK_KIND【种类】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>种类ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>种类名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IMAGE</td>
<td>种类图片</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PIRCE</td>
<td>价格</td>
<td>DECIMAL(32,8)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>STANDARD_ID</td>
<td>所属执行标准</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CONMPOSITIONS_ID</td>
<td>所属组成成分</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FUNCTION_ID</td>
<td>所属功能</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RANGE_ID</td>
<td>适用场景</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DIMENSIONS</td>
<td>尺寸规格</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VENDORS</td>
<td>生产厂商</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_STANDARD-from"><h6 id="module-MASK-tableColumnList-MASK_STANDARD">MASK_STANDARD【执行标准】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>标准ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>标准名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LEVEL</td>
<td>防护等级</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_FUNCTION-from"><h6 id="module-MASK-tableColumnList-MASK_FUNCTION">MASK_FUNCTION【功能】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>功能ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>FUNCTIONS</td>
<td>功能项</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NOTICE</td>
<td>注意项</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CYCLE</td>
<td>使用周期</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>THEORY</td>
<td>工作原理</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_COMPOSITIONS-from"><h6 id="module-MASK-tableColumnList-MASK_COMPOSITIONS">MASK_COMPOSITIONS【产品构成】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>组成成分ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>GATHER</td>
<td>构成</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FORM</td>
<td>形式</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RESERVE</td>
<td>储存条件</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BATCHNUM</td>
<td>生产批号</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PRODUCTDATE</td>
<td>生产日期</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VALIDITY</td>
<td>有效期</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ENTERPRISE</td>
<td>生产企业</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ADDRESS</td>
<td>生产地址</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_USER-from"><h6 id="module-MASK-tableColumnList-MASK_USER">MASK_USER【使用对象】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>对象ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>对象名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>KIND_ID</td>
<td>种类ID</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GENDER</td>
<td>性别</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AGE</td>
<td>年龄</td>
<td>INT</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PROFESSION</td>
<td>职业</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CHANNEL</td>
<td>购买渠道</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RISK_ID</td>
<td>风险等级</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UNSUITABLE_USER</td>
<td>不适人群</td>
<td>VARCHAR(512)</td>
<td></td>
<td>心脏或呼吸系统有困难的人（如哮喘肺气肿）、怀孕、佩戴后头晕、呼吸困难和皮肤敏感。</td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_RANGE-from"><h6 id="module-MASK-tableColumnList-MASK_RANGE">MASK_RANGE【适用场景】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>场景ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>场景名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RISK_ID</td>
<td>风险等级</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<ul>
<li><a href="#module-MASK-tableColumnList-MASK_RISK-from"><h6 id="module-MASK-tableColumnList-MASK_RISK">MASK_RISK【风险等级】</h6></a></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
<th>数据类型(MYSQL)</th>
<th>主键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>风险ID</td>
<td>VARCHAR(32)</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>NAME</td>
<td>等级名称</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>EXPLAIN</td>
<td>风险说明</td>
<td>VARCHAR(512)</td>
<td></td>
<td>高、较高、中、较低、低等级 判定</td>
</tr>
<tr>
<td>CREATED_BY</td>
<td>创建人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATED_TIME</td>
<td>创建时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_BY</td>
<td>更新人</td>
<td>VARCHAR(32)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATED_TIME</td>
<td>更新时间</td>
<td>DATETIME</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
]]></content>
      <tags>
        <tag>数据建模</tag>
        <tag>PDMan</tag>
      </tags>
  </entry>
  <entry>
    <title>数据安全</title>
    <url>/2016/04/05/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="1-Base64"><a href="#1-Base64" class="headerlink" title="1.Base64"></a>1.Base64</h3><h4 id="1-Base64简单说明"><a href="#1-Base64简单说明" class="headerlink" title="1.Base64简单说明"></a>1.Base64简单说明</h4><pre><code>描述：Base64可以成为密码学的基石，非常重要。
特点：可以将任意的二进制数据进行Base64编码
结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。
65字符：A~Z a~z 0~9 + / =
对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。
</code></pre>
<h4 id="2-命令行进行Base64编码和解码"><a href="#2-命令行进行Base64编码和解码" class="headerlink" title="2.命令行进行Base64编码和解码"></a>2.命令行进行Base64编码和解码</h4><pre><code>编码：base64 123.png -o 123.txt
解码：base64 123.txt -o test.png -D
</code></pre>
<span id="more"></span>
<h4 id="3-Base64编码原理"><a href="#3-Base64编码原理" class="headerlink" title="3.Base64编码原理"></a>3.Base64编码原理</h4><pre><code>1)将所有字符转化为ASCII码；
2)将ASCII码转化为8位二进制；
3)将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；
4)统一在6位二进制前补两个0凑足8位；
5)将补0后的二进制转为十进制；
6)从Base64编码表获取十进制对应的Base64编码；
</code></pre>
<p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。<br>    b.数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加1个“&#x3D;”；<br>    e.如果最后剩下一个输入数据，编码结果后加2个“&#x3D;”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</p>
<h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h4><pre><code>a.说明：
    1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持
    2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。

b.相关代码：
//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果
-(NSString *)base64EncodeString:(NSString *)string
&#123;
    //1.先把字符串转换为二进制数据
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];

    //2.对二进制数据进行base64编码，返回编码后的字符串
    return [data base64EncodedStringWithOptions:0];
&#125;

//对base64编码后的字符串进行解码
-(NSString *)base64DecodeString:(NSString *)string
&#123;
    //1.将base64编码后的字符串『解码』为二进制数据
    NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0];

    //2.把二进制数据转换为字符串返回
    return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
&#125;

c.终端测试命令
    $ echo -n A | base64
    $ echo -n QQ== |base64 -D
</code></pre>
<h3 id="2-常见的加密算法和其它"><a href="#2-常见的加密算法和其它" class="headerlink" title="2.常见的加密算法和其它"></a>2.常见的加密算法和其它</h3><ul>
<li>base64 编码格式</li>
<li>密码学演化 “秘密本”–&gt;RSA</li>
<li>常见的加密算法<ul>
<li>消息摘要（单向散列函数）</li>
<li>对称加密</li>
<li>非对称加密</li>
<li>证书等</li>
</ul>
</li>
</ul>
<h3 id="3-单向散列函数"><a href="#3-单向散列函数" class="headerlink" title="3.单向散列函数"></a>3.单向散列函数</h3><h4 id="1-单向散列函数的特点："><a href="#1-单向散列函数的特点：" class="headerlink" title="1.单向散列函数的特点："></a>1.单向散列函数的特点：</h4><pre><code>①加密后密文的长度是定长的
②如果明文不一样，那么散列后的结果一定不一样
③如果明文一样，那么加密后的密文一定一样（对相同数据加密，加密后的密文一样）
④所有的加密算法是公开的
⑤不可以逆推反算
</code></pre>
<h4 id="2-经典加密算法"><a href="#2-经典加密算法" class="headerlink" title="2.经典加密算法"></a>2.经典加密算法</h4><pre><code>1）MD5加密
2）SHA1
3）SHA512
</code></pre>
<h4 id="3-MD5加密算法简单说明"><a href="#3-MD5加密算法简单说明" class="headerlink" title="3.MD5加密算法简单说明"></a>3.MD5加密算法简单说明</h4><pre><code>1）对字符串进行MD5加密可以得到一个32个字符的密文
2）加密之后不能根据密文逆推出明文
3）MD5已经被破解（暴力破解|碰撞检测）
</code></pre>
<h4 id="4-MD5加密进阶"><a href="#4-MD5加密进阶" class="headerlink" title="4.MD5加密进阶"></a>4.MD5加密进阶</h4><pre><code>1）先加盐，然后再进行MD5
2）先乱序，再进行MD5加密
3）乱序|加盐，多次MD5加密等
4）使用消息认证机制，即HMAC-MD5-先对密钥进行加密，加密之后进行两次MD5散列
5）加密命令行
    MD5加密-字符串    $ echo -n &quot;520it&quot; |md5
    MD5加密-文件1     $ md5 abc.png
    SHA1加密：        $ echo -n &quot;520it&quot; |openssl sha -sha1
    SHA256            $ echo -n &quot;520it&quot; |openssl sha -sha256
    SHA512            $ echo -n &quot;520it&quot; |openssl sha -sha512
    hmacMD5加密       $ echo -n &quot;520it&quot; |openssl dgst -md5 -hmac &quot;123&quot;
</code></pre>
<h4 id="5-散列函数应用领域"><a href="#5-散列函数应用领域" class="headerlink" title="5.散列函数应用领域"></a>5.散列函数应用领域</h4><pre><code>1）搜索 多个关键字，先对每个关键字进行散列，然后多个关键字进行或运算，如果值一致则搜索结果一致
2）版权 对文件进行散列判断该文件是否是正版或原版的
3）文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改
</code></pre>
<h4 id="6-消息认证机制（HMAC）简单说明"><a href="#6-消息认证机制（HMAC）简单说明" class="headerlink" title="6.消息认证机制（HMAC）简单说明"></a>6.消息认证机制（HMAC）简单说明</h4><pre><code>1）原理
    ①消息的发送者和接收者有一个共享密钥
    ②发送者使用共享密钥对消息加密计算得到MAC值（消息认证码）
    ③消息接收者使用共享密钥对消息加密计算得到MAC值
    ④比较两个MAC值是否一致
2）使用
    ①客户端需要在发送的时候把（消息）+（消息·HMAC）一起发送给服务器
    ②服务器接收到数据后，对拿到的消息用共享的KEY进行HMAC，比较是否一致，如果一致则信任
</code></pre>
<h3 id="4-对称加密"><a href="#4-对称加密" class="headerlink" title="4.对称加密"></a>4.对称加密</h3><h4 id="1-对称加密的特点"><a href="#1-对称加密的特点" class="headerlink" title="1.对称加密的特点"></a>1.对称加密的特点</h4><pre><code>1）加密/解密使用相同的密钥
2）加密和解密的过程是可逆的（明文-》明文-》明文）
</code></pre>
<h4 id="2-经典算法"><a href="#2-经典算法" class="headerlink" title="2.经典算法"></a>2.经典算法</h4><pre><code>1）DES 数据加密标准
2）3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密）
3）AES 高级加密标准
</code></pre>
<h4 id="3-分组密码简单说明"><a href="#3-分组密码简单说明" class="headerlink" title="3.分组密码简单说明"></a>3.分组密码简单说明</h4><pre><code>密码算法可以分为分组密码和流密码两种。
分组密码：每次只能处理特定长度的一zu数据的一类密码算法。一个分组的比特数量就称之为分组长度。
ex:DES和3DES的分组长度都是64比特。即每次只能加密64比特的明文，并生成64比特的密文。AES的分组长度有128比特、192比特和256比特可以选择。
流密码：对数据流进行连续处理的一类算法。流密码中一般以1比特、8比特或者是32比特等作为单位俩进行加密和解密。
</code></pre>
<h4 id="4-ECB分组模式"><a href="#4-ECB分组模式" class="headerlink" title="4.ECB分组模式"></a>4.ECB分组模式</h4><pre><code>ECB模式的全称为Electronic CodeBook模式。又成为电子密码本模式。
特点：
1）使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组。
2）类似于一个巨大的明文分组-》密文分组的对照表。
</code></pre>
<p><img src="/Users/nick/Desktop/1.png"></p>
<pre><code>终端测试命令：
加密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.txt -out 123.bin
解密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.bin -out 1231.txt -d
</code></pre>
<h4 id="5-CBC分组模式"><a href="#5-CBC分组模式" class="headerlink" title="5.CBC分组模式"></a>5.CBC分组模式</h4><pre><code>CBC模式全称为Cipher Block Chainning模式（密文分组链接模式|电子密码链条）
特点：在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。


终端命令：
加密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.txt -out a.bin
解密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.bin -out a1.txt -d
</code></pre>
<h3 id="5-非对称加密"><a href="#5-非对称加密" class="headerlink" title="5.非对称加密"></a>5.非对称加密</h3><h4 id="1-非对称加密的特点"><a href="#1-非对称加密的特点" class="headerlink" title="1.非对称加密的特点"></a>1.非对称加密的特点</h4><pre><code>1）使用公钥加密，使用私钥解密
2）公钥是公开的，私钥保密
3）加密处理安全，但是性能极差
</code></pre>
<p><img src="/Users/nick/Desktop/2.png"></p>
<h4 id="2-经典算法—RSA"><a href="#2-经典算法—RSA" class="headerlink" title="2.经典算法—RSA"></a>2.经典算法—RSA</h4><pre><code>1）RSA 原理
    （1）求N，准备两个质数p和q,N = p x q
    （2）求L,L是p-1和q-1的最小公倍数。L = lcm（p-1,q-1）
    （3）求E，E和L的最大公约数为1（E和L互质）
    （4）求D，E x D mode L = 1
2）RSA加密小实践
    （1）p = 17,q = 19 =&gt;N = 323
    （2）lcm（p-1,q-1）=&gt;lcm（16，18）=&gt;L= 144
    （3）gcd（E,L）=1 =&gt;E=5
    （4）E乘以几可以mode L =1? D=29可以满足
    （5）得到公钥为：E=5,N=323
    （6）得到私钥为：D=29,N=323
    （7）加密 明文的E次方 mod N = 123的5次方 mod 323 = 225（密文）
    （8）解密 密文的D次方 mod N = 225的29次方 mod 323 = 123（明文）
    ----------------
3）openssl生成密钥命令
    生成强度是 512 的 RSA 私钥：$ openssl genrsa -out private.pem 512
    以明文输出私钥内容：$ openssl rsa -in private.pem -text -out private.txt
    校验私钥文件：$ openssl rsa -in private.pem -check
    从私钥中提取公钥：$ openssl rsa -in private.pem -out public.pem -outform PEM -pubout
    以明文输出公钥内容：$ openssl rsa -in public.pem -out public.txt -pubin -pubout -text
    使用公钥加密小文件：$ openssl rsautl -encrypt -pubin -inkey public.pem -in msg.txt -out msg.bin
    使用私钥解密小文件：$ openssl rsautl -decrypt -inkey private.pem -in msg.bin -out a.txt
    将私钥转换成 DER 格式：$ openssl rsa -in private.pem -out private.der -outform der
    将公钥转换成 DER 格式：$ openssl rsa -in public.pem -out public.der -pubin -outform der
    -----------------
</code></pre>
<h3 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6.数字签名"></a>6.数字签名</h3><h4 id="1-数字签名的应用场景"><a href="#1-数字签名的应用场景" class="headerlink" title="1.数字签名的应用场景"></a>1.数字签名的应用场景</h4><pre><code>答：需要严格验证发送方身份信息情况
</code></pre>
<h4 id="2-数字签名原理"><a href="#2-数字签名原理" class="headerlink" title="2.数字签名原理"></a>2.数字签名原理</h4><pre><code>1）客户端处理
    ①对&quot;消息&quot;进行 HASH 得到 &quot;消息摘要&quot;
    ②发送方使用自己的私钥对&quot;消息摘要&quot; 加密(数字签名)
    ③把数字签名附着在&quot;报文&quot;的末尾一起发送给接收方
2）服务端处理
    ①对&quot;消息&quot; HASH 得到 &quot;报文摘要&quot;
    ②使用公钥对&quot;数字签名&quot; 解密
    ③对结果进行匹配
</code></pre>
<p><img src="/Users/nick/Desktop/3.png"></p>
<h3 id="7-数字证书"><a href="#7-数字证书" class="headerlink" title="7.数字证书"></a>7.数字证书</h3><h4 id="1-简单说明"><a href="#1-简单说明" class="headerlink" title="1.简单说明"></a>1.简单说明</h4><pre><code>证书和驾照很相似，里面记有姓名、组织、地址等个人信息，以及属于此人的公钥，并有认证机构施加数字签名,只要看到公钥证书，我们就可以知道认证机构认证该公钥的确属于此人
</code></pre>
<h4 id="2-数字证书的内容"><a href="#2-数字证书的内容" class="headerlink" title="2.数字证书的内容"></a>2.数字证书的内容</h4><pre><code>1）公钥
2）认证机构的数字签名
</code></pre>
<h4 id="3-证书的生成步骤"><a href="#3-证书的生成步骤" class="headerlink" title="3.证书的生成步骤"></a>3.证书的生成步骤</h4><pre><code>1）生成私钥 openssl genrsa -out private.pem 1024
2）创建证书请求 openssl req -new -key private.pem -out rsacert.csr
3）生成证书并签名，有效期10年 openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt
4）将 PEM 格式文件转换成 DER 格式 openssl x509 -outform der -in rsacert.crt -out rsacert.der
5）导出P12文件 openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt
</code></pre>
<h4 id="4-iOS开发中的注意点"><a href="#4-iOS开发中的注意点" class="headerlink" title="4.iOS开发中的注意点"></a>4.iOS开发中的注意点</h4><pre><code>1）在iOS开发中，不能直接使用 PEM 格式的证书，因为其内部进行了Base64编码，应该使用的是DER的证书，是二进制格式的
2）OpenSSL默认生成的都是PEM格式的证书
</code></pre>
]]></content>
      <categories>
        <category>数据安全</category>
      </categories>
      <tags>
        <tag>数据加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter  侧滑会导致 TextField 获取不到焦点？</title>
    <url>/2024/11/22/Flutter-%E4%BE%A7%E6%BB%91%E4%BC%9A%E5%AF%BC%E8%87%B4-TextField-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%84%A6%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<p>最近 Flutter写功能的时候发现一个 bug ：侧滑会导致 TextField 获取不到焦点 无法继续编辑文本内容</p>
<p>flutter版本是 3.22.1 目前是最新的版本 以前的版本不确定有没有类似情况 </p>
<span id="more"></span>

<h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>ios 自带有侧滑功能， A界面有 TextField， B 界面也有 TextField </p>
<h4 id="触发："><a href="#触发：" class="headerlink" title="触发："></a>触发：</h4><p>从 A 界面跳转到 B 界面  然后在 B 界面触发侧滑 返回到 A界面或者侧滑一点还停留在 B 界面</p>
<h4 id="查找问题："><a href="#查找问题：" class="headerlink" title="查找问题："></a>查找问题：</h4><p>断点调试发现 没侧滑或者点击返回按钮时 FocusNode#b87c0(context: Focus)<br>但是侧滑返回的时候 FocusNode#b87c0(context: Focus, NOT FOCUSABLE)<br>多了一个 NOT FOCUSABLE<br>会将canRequestFocus改为false</p>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>统一处理方法：新建CustomFocusNode类 将canRequestFocus设置为true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CustomFocusNode extends FocusNode &#123;</span><br><span class="line">  @override</span><br><span class="line">  bool get canRequestFocus =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再将使用到<code> FocusNode focusNode = FocusNode();</code>初始化的地方 替换为<code> CustomFocusNode focusNode = CustomFocusNode();</code>即可。</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>私有项目或功能集成到SVN 通过pod下载</title>
    <url>/2019/07/16/%E7%A7%81%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%88%96%E5%8A%9F%E8%83%BD%E9%9B%86%E6%88%90%E5%88%B0SVN-%E9%80%9A%E8%BF%87pod%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.jianshu.com/p/cbb8931499da">结合cocoapods谈iOS私有库的三种管理方式</a><br><a href="https://www.jianshu.com/p/217841b3eb7d">利用公司SVN服务器 使用cocoaPods管理自己的私有库</a></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><strong>注：</strong> 需要安装repo-svn插件 <code>gem install cocoapods-repo-svn</code> （PS：会报权限问题，出现的Error可以忽略，改成<code>sudo gem install cocoapods-repo-svn</code>）</p>
<span id="more"></span>
<ul>
<li>创建podspec文件   <code>pod spec create 文件名</code></li>
<li>将项目或功能上传至SVN<ul>
<li>有(branches、tags、trunk)三个目录 一般放到truck或者branches里 </li>
<li>通过打标签设置版本号 (先在tags里创建该文件空的，然后选择tag选择到该文件下打版本标签)</li>
</ul>
</li>
<li><code>pod repo-svn add tags  svn上tags的地址</code> （添加项目）   可在 <code>~/.cocoapods/repos/</code> 查看</li>
<li><code>pod repo-svn update tags</code> （更新项目）</li>
<li>可在podfile文件中添加 （tags在svn上的地址）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugin &#x27;cocoapods-repo-svn&#x27;, :sources =&gt; [</span><br><span class="line">   中括号内的 为tags在SVN上的地址、也是podspec里source地址加上/tags</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>直接 <code>pod ‘名称’, ‘版本号’ </code></li>
<li><code>pod install</code> 即可 </li>
<li>若有修改SVN中的文件 需要先 删除pod缓存 <code>open ~/Library/Caches/Cocoapods </code> 再<code>pod install</code></li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>可通过 <code>pod spec lint TrackAction.podspec --verbose --use-libraries --allow-warnings</code> 检查错误 </p>
</li>
<li><p>集成到GitHub 通过pod管理  原理类似  可在简书 <a href="https://www.jianshu.com/bookmarks">收藏的文章</a> 中查找 </p>
</li>
<li><p>cocoapods缓存问题  解决修改了tags里内容但pod下来却没有更新<br>   删除pod  <code>~/Library/Caches/Cocoapods </code>  <br>   <a href="https://www.jianshu.com/p/f936794aa512">https://www.jianshu.com/p/f936794aa512</a>  </p>
</li>
<li><p>需要注意的地方 在项目中写在pch的头文件 若要集成出来  需要在对应的文件里写上这个头文件 不然会报错找不到</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SVN</tag>
        <tag>cocoapods</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>sonar代码检测插件</title>
    <url>/2019/08/27/sonar%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>SonarQube®是一种自动代码审查工具，用于检测代码中的错误，漏洞和代码异味。它可以与您现有的工作流程集成，以便在项目分支和拉取请求之间进行连续的代码检查。</p>
<span id="more"></span>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/6b61783b9a38">基于Sonar的iOS代码质量检测系统</a><br><a href="https://www.jianshu.com/p/b41262fca5b8">mac搭建SonarQube</a><br><a href="https://www.jianshu.com/p/7f3b08e3a479">iOS mac sonar安装指南</a><br><a href="https://www.jianshu.com/p/3b70aa6af07b">Objective C接入Sonar代码扫描</a></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><h5 id="演示版本："><a href="#演示版本：" class="headerlink" title="演示版本："></a>演示版本：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK：1.8.0_221</span><br><span class="line">MySQL：5.7.27</span><br><span class="line">Sonarqube：7.1</span><br><span class="line">Sonar-runner：2.4</span><br><span class="line">Sonar-scanner：3.3.0.1492-macosx</span><br></pre></td></tr></table></figure>

<h5 id="Java环境与MySQL安装"><a href="#Java环境与MySQL安装" class="headerlink" title="Java环境与MySQL安装"></a>Java环境与MySQL安装</h5><ul>
<li>进入<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">jdk1.8</a>安装界面,下载macos版本</li>
<li>进入<a href="https://dev.mysql.com/downloads/mysql/5.6.html#downloads">MySQL</a>下载界面，下载之后安装，安装完成后，进入系统偏好设置，可看到MySql选项，代表已安装成功</li>
</ul>
<h5 id="需要的插件"><a href="#需要的插件" class="headerlink" title="需要的插件"></a>需要的插件</h5><ul>
<li><p>sonarqube</p>
<ul>
<li><a href="https://www.sonarqube.org/downloads/">服务端 sonarqube</a> </li>
<li><a href="http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.3/sonar-runner-dist-2.4.zip">客户端 sonar-runner</a> 解压路径：&#x2F;user&#x2F;local</li>
</ul>
</li>
<li><p>Sonar-Scanner<br>下载解压到&#x2F;usr&#x2F;local  <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner">Sonar-Scanner</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install sonar-scanner</span><br></pre></td></tr></table></figure></li>
<li><p>Xcpretty</p>
</li>
</ul>
<p>最新方法： <code>sudo gem install xcpretty -n/usr/local/bin</code><br>旧方法：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Backelite/xcpretty.git</span><br><span class="line">cd xcpretty</span><br><span class="line">git checkout fix/duration_of_failed_tests_workaround</span><br><span class="line">gem build xcpretty.gemspec</span><br><span class="line">sudo gem install --both xcpretty-0.2.2.gem -n/usr/local/bin</span><br></pre></td></tr></table></figure></p>
<ul>
<li>OCLint</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap oclint/formulae    </span><br><span class="line">brew install oclint</span><br></pre></td></tr></table></figure>
<p> 检查路径：&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;oclint&#x2F;0.13</p>
<ul>
<li>slather</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gem install slather</span><br></pre></td></tr></table></figure>
<ul>
<li>lizard<ul>
<li><code>sudo pip install lizard</code></li>
<li>若没有安装pip 下载文件 <a href="/download/get-pip.py">get-pip.py</a></li>
<li>并执行<code>sudo python get-pip.py</code></li>
</ul>
</li>
<li>sonar-objective-c-plugin-0.5.0-SNAPSHOT.jar<br>插件下载地址:<a href="https://github.com/ChenTF/iOS-sonarShell">https://github.com/ChenTF/iOS-sonarShell</a><br>解压放在：sonarqube-7.1&#x2F;extensions&#x2F;plugins&#x2F;</li>
</ul>
<h5 id="最后环境目录组成-usr-local"><a href="#最后环境目录组成-usr-local" class="headerlink" title="最后环境目录组成 &#x2F;usr&#x2F;local"></a>最后环境目录组成 &#x2F;usr&#x2F;local</h5><p><img src="/images/sonar%E7%9B%AE%E5%BD%95.png" alt="sonar目录"></p>
<h4 id="创建MySQL数据库"><a href="#创建MySQL数据库" class="headerlink" title="创建MySQL数据库"></a>创建MySQL数据库</h4> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql-5.7.27-macos10.14-x86_64/bin</span><br><span class="line"></span><br><span class="line">mysql -u root -p </span><br><span class="line">mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; CREATE USER &#x27;sonar&#x27; IDENTIFIED BY &#x27;sonar&#x27;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &#x27;sonar&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;sonar&#x27;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &#x27;sonar&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;sonar&#x27;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><ul>
<li>修改confsonar.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonarqube-7.1/confsonar.properties</span><br><span class="line"></span><br><span class="line">sonar.host.url=http://localhost:9000/sonarqube</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br></pre></td></tr></table></figure>

<ul>
<li>修改wrapper.conf</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonarqube-7.1/wrapper.conf </span><br><span class="line">wrapper.java.command=/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java</span><br></pre></td></tr></table></figure>

<ul>
<li>修改sonar.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonarqube-7.1/conf/sonar.properties</span><br><span class="line"></span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</span><br><span class="line">sonar.jdbc.maxActive=60</span><br><span class="line">sonar.jdbc.maxIdle=5</span><br><span class="line">sonar.jdbc.minIdle=2</span><br><span class="line">sonar.jdbc.maxWait=5000</span><br><span class="line">sonar.jdbc.minEvictableIdleTimeMillis=600000</span><br><span class="line">sonar.jdbc.timeBetweenEvictionRunsMillis=30000</span><br></pre></td></tr></table></figure>

<ul>
<li>修改sonar-runner.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/sonar-runner-2.4/conf/sonar-runner.properties</span><br><span class="line"></span><br><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 sonar-scanner.properties</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#----- Default SonarQube server</span><br><span class="line">sonar.host.url=http://localhost:9000/sonarqube</span><br><span class="line"></span><br><span class="line">#----- Default source code encoding</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br></pre></td></tr></table></figure>

<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export OCLINT_HOME=/usr/local/Cellar/oclint/0.13</span><br><span class="line">export PATH=$OCLINT_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">退出  :wq</span><br><span class="line">保存  source ~/.bash_profile</span><br><span class="line">验证  sonar-runner -version</span><br></pre></td></tr></table></figure>
<p><strong>注：检查JAVA_HOME 和 OCLINT_HOME 的路径是否正确 可能有不同</strong></p>
<p>修改完成保存后，终端执行<br><code>cd /usr/local/sonarqube-7.1/bin/macosx-universal-64</code> 和 <code>./sonar.sh start</code><br>打开浏览器访问<a href="http://localhost:9000/">http://localhost:9000</a> 若正常进入则配置成功</p>
<p><strong>安装中文插件</strong><br><img src="https://upload-images.jianshu.io/upload_images/6693936-15f9b678d17617f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p>
<h4 id="项目内需要的两个文件（根目录）"><a href="#项目内需要的两个文件（根目录）" class="headerlink" title="项目内需要的两个文件（根目录）"></a>项目内需要的两个文件（根目录）</h4><p><a href="/download/run-sonar.sh">run-sonar.sh</a><br><a href="/download/sonar-project.properties">sonar-project.properties</a>（可修改对应的项目名称、版本号）</p>
<p>启动sonar<br><code>cd /usr/local/sonarqube-7.1/bin/macosx-universal-64</code> 和 <code>./sonar.sh start</code><br>最后在项目根目录执行<br><code>./run-sonar.sh</code></p>
<h3 id="安装执行过程中的命令"><a href="#安装执行过程中的命令" class="headerlink" title="安装执行过程中的命令"></a>安装执行过程中的命令</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>查看数据库<br><code>SHOW DATABASES; </code><br>删除数据库<br><code>DROP DATABASE sonar; </code><br>查看账户<br><code>select user,host from user; </code><br>删除账户<br><code>delete from mysql.user where user=&#39;sonar&#39;;</code> <br>启动<br><code>sudo /usr/local/mysql/support-files/mysql.server start</code><br>停止<br><code>sudo /usr/local/mysql/support-files/mysql.server stop</code><br>重启<br><code>sudo /usr/local/mysql/support-files/mysql.server restart</code></p>
<p><strong>注：</strong> <a href="https://www.jianshu.com/p/4cc5640eec4b">完全卸载MAC上的mysql</a></p>
<h4 id="sonarqube"><a href="#sonarqube" class="headerlink" title="sonarqube"></a>sonarqube</h4><p><code>cd /usr/local/sonarqube-7.1/bin/macosx-universal-64</code><br>启动<br><code>./sonar.sh start</code><br>停止<br><code>./sonar.sh stop</code><br>重启<br><code>./sonar.sh restart</code></p>
<h3 id="安装执行过程中的问题"><a href="#安装执行过程中的问题" class="headerlink" title="安装执行过程中的问题"></a>安装执行过程中的问题</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main ERROR Null object returned for RollingFile in Appenders.</span><br><span class="line">main ERROR Unable to locate appender &quot;file_es&quot; for logger config &quot;root&quot;</span><br></pre></td></tr></table></figure>
<p>解决：需要将配置文件log4j2.properties  中<code>logger.deprecation.level=warn</code>  改为 ERROR   ( 文件位置<code>/user/local/sonarqube-7.1/temp</code>)  <strong>若没有该设置 直接添加</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WrapperSimpleApp: Encountered an error running main: java.nio.file.AccessDeniedException:</span><br></pre></td></tr></table></figure>
<p>解决：删除 <code>/user/local/sonarqube-7.1/temp</code> 文件下所有内容即可</p>
<hr>
<p>mac下安装mysql，连接出现Access denied for user ‘root‘@’localhost’ (using password: YES)<br>解决：<a href="https://blog.csdn.net/lyl123_456/article/details/82426212">https://blog.csdn.net/lyl123_456/article/details/82426212</a></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: Re-run SonarQube Scanner using the -X switch to enable full debug logging.ERROR: SonarQube scanner exited with non-zero code: 1Finished: FAILURE</span><br></pre></td></tr></table></figure>
<p>解决：<img src="/images/sonarqube%E9%85%8D%E7%BD%AE.png" alt="问题解决"></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Another active Homebrew update process is already in progress. Please wait for it to finish or terminate it to continue.</span><br></pre></td></tr></table></figure>
<p>解决： 执行 <code>rm -rf /usr/local/var/homebrew/locks</code></p>
<hr>
<p>扫描成功后最后查看网站，代码重复率有数字，其他代码质量为0<br>解决：查看project：sonar-project.properties文件，配置这2句 可以尝试。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sonar.objectivec.oclint.report=oclint.xml（这个是报告的名字）</span><br><span class="line">sonar.objectivec.oclint.reportPath=sonar-reports/oclint.xml（这个是报告的路径）</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1046 (3D000): No database selected</span><br></pre></td></tr></table></figure>
<p>解决： <code>mysql&gt; use mysql</code></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1396 (HY000): Operation CREATE USER failed for &#x27;sonar&#x27;@&#x27;%&#x27;</span><br></pre></td></tr></table></figure>
<p>解决：换个名称<code>CREATE USER &#39;sonarqube&#39; IDENTIFIED BY &#39;sonarqube&#39;;</code></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.FileNotFoundException: /usr/local/sonarqube-7.1/extensions/plugins/sonar-objective-c-plugin-0.5.0-SNAPSHOT.jar (No such file or directory)</span><br></pre></td></tr></table></figure>
<p>解决：冲突 去掉对应的文件 重新运行sonar</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: can not run elasticsearch as root</span><br></pre></td></tr></table></figure>
<p>解决：运行命令将<code>sudo /usr/local//sonarqube-7.1/bin/macosx-universal-64/sonar.sh start</code> 修改为 <code>cd /usr/local//sonarqube-7.1/bin/macosx-universal-64</code>  和  <code>./sonar.sh start</code> </p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若项目根目录 执行 ./run-sonar.sh 出错 -bash: ./run-sonar.sh: Permission denied  </span><br></pre></td></tr></table></figure>
<p>解决：<code>chmod u=rxw run-sonar.sh</code> 修改权限</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: one compiler command contains multiple jobs:  </span><br></pre></td></tr></table></figure>
<p>解决：<br>     •	将 Project 和 Targets 中 Building Settings 下的 COMPILER_INDEX_STORE_ENABLE 设置为 NO<br>     •	在 podfile 中 target ‘xx’ do 前面添加下面的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">    installer.pods_project.targets.each do |target|</span><br><span class="line">        target.build_configurations.each do |config|</span><br><span class="line">            config.build_settings[&#x27;COMPILER_INDEX_STORE_ENABLE&#x27;] = &quot;NO&quot;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>代码质量检测</category>
      </categories>
      <tags>
        <tag>sonar</tag>
      </tags>
  </entry>
  <entry>
    <title>xcode 真机正常运行但模拟器报错的一种解决方法</title>
    <url>/2025/01/09/xcode-%E7%9C%9F%E6%9C%BA%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%BD%86%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%8A%A5%E9%94%99%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>xcode15 版本 有的项目 真机运行正常 但是模拟器不能正常运行（可能某些第三方库 不支持 arm64 ）</p>
<span id="more"></span>

<p>网上找到的一种方法是 <strong>Excluded Architectures 加上arm64</strong><br>但这样设置 模拟器是可以正常运行了，但是真机又会报错无法运行</p>
<p><code>Excluded Architectures</code>里有 Debug&#x2F;Release 两种，根据使用模拟器的需要<br>添加一条 <code>Any iOS Simulator SDK</code> 然后加上 arm64 这样真机和模拟器都能跑项目了</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>有的第三方库是不支持 arm64 的,或者有的库iOS deployment Target支持的最低版本比现在xcode支持的最低版本比如是13 还低<br>需要在PodFile中加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">  installer.pods_project.targets.each do |target|</span><br><span class="line">    target.build_configurations.each do |config|</span><br><span class="line">      config.build_settings[&#x27;EXCLUDED_ARCHS[sdk=iphonesimulator*]&#x27;] = &quot;arm64&quot;</span><br><span class="line">      config.build_settings[&#x27;IPHONEOS_DEPLOYMENT_TARGET&#x27;] = &#x27;13.0&#x27; # 你想设置的版本</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>统一设置</p>
]]></content>
  </entry>
  <entry>
    <title>画中画在 iOS18 中失效？</title>
    <url>/2024/11/13/%E7%94%BB%E4%B8%AD%E7%94%BB%E5%9C%A8-iOS18-%E4%B8%AD%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h4 id="最新进展"><a href="#最新进展" class="headerlink" title="最新进展"></a>最新进展</h4><p><a href="https://developer.apple.com/documentation/avkit/adopting-picture-in-picture-for-video-calls">Adopting Picture in Picture for video calls</a><br>看官方文档发现苹果认可使用画中画的方式有两种，一种是播放视频，另一种则是视频通话。在高于 iOS 18 和 Xcode 16 版本时，播放视频的画中画会在启用相机后自动禁用。但是如果使用视频通话的画中画则可以正常运行,通话不能中断吧</p>
<p><strong>区别：</strong><br>播放视频：双击放大缩小、有控制按钮(可隐藏)<br>视频通话：轻点会回到app 且没有控制按钮，不能修改尺寸</p>
<span id="more"></span>

<h4 id="记录一次-升级xcode的坑"><a href="#记录一次-升级xcode的坑" class="headerlink" title="记录一次 升级xcode的坑"></a>记录一次 升级xcode的坑</h4><p>AVPictureInPictureController  画中画 iOS18 打开相机后失效</p>
<ul>
<li>用 xcode16     运行 iOS18   画中画在相机里失效</li>
<li>用 xcode16     运行 iOS17   画中画在相机里正常</li>
<li>用 xcode15.4  运行 iOS18   画中画在相机里正常</li>
</ul>
<p>如果不升级xcode就没有问题，但这也不是根本解决方法 可能还要等xcode的修复这个问题吧<br>网上和ChatGPT都没有类似情况<br>发现是版本问题 也是巧合 正好使用xcode15.4打包项目<br>苹果新规定 2025年4月24号之后 打包的ipa必须是xcode16以上了（比较喜欢这种强制升级的  断舍离）</p>
]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>web3 学习</title>
    <url>/2025/02/28/web3-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="2025-年-Web3-应用开发与前端开发学习路线"><a href="#2025-年-Web3-应用开发与前端开发学习路线" class="headerlink" title="2025 年 Web3 应用开发与前端开发学习路线"></a>2025 年 Web3 应用开发与前端开发学习路线</h1><p>本学习路线涵盖从入门到进阶的知识点，提供可跳转的链接，涵盖常用开发工具（如 RainbowKit 等），并列举了在 Bilibili 和 YouTube 上点赞评论较高、发布时间较新的 Web3 相关视频。</p>
<span id="more"></span>
<h2 id="1-前端开发基础"><a href="#1-前端开发基础" class="headerlink" title="1. 前端开发基础"></a>1. 前端开发基础</h2><p>在开始 Web3 开发之前，掌握前端开发的基础知识是必要的。</p>
<ul>
<li><p><strong>HTML 与 CSS</strong>：学习如何构建和设计网页。</p>
<ul>
<li><a href="https://www.w3schools.com/html/">W3Schools HTML 教程</a></li>
<li><a href="https://www.w3schools.com/css/">W3Schools CSS 教程</a></li>
</ul>
</li>
<li><p><strong>JavaScript</strong>：作为前端开发的核心语言，掌握其语法和功能。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">MDN JavaScript 教程</a></li>
</ul>
</li>
<li><p><strong>前端框架</strong>：学习主流的前端框架，如 React、Vue 或 Angular，以提高开发效率。</p>
<ul>
<li><a href="https://reactjs.org/docs/getting-started.html">React 官方文档</a></li>
<li><a href="https://vuejs.org/v2/guide/">Vue.js 官方文档</a></li>
<li><a href="https://angular.io/docs">Angular 官方文档</a></li>
</ul>
</li>
</ul>
<h2 id="2-Web3-基础知识"><a href="#2-Web3-基础知识" class="headerlink" title="2. Web3 基础知识"></a>2. Web3 基础知识</h2><p>理解 Web3 的基本概念和区块链原理是开发去中心化应用的前提。</p>
<ul>
<li><p><strong>区块链基础</strong>：了解区块链的工作原理、共识机制和应用场景。</p>
<ul>
<li><a href="https://ethereum.org/zh/developers/docs/">以太坊官方文档</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">区块链技术入门</a></li>
</ul>
</li>
<li><p><strong>Web3 概述</strong>：了解 Web3 的起源、愿景以及与 Web2 的区别。</p>
<ul>
<li><a href="https://www.web3.foundation/zh/">Web3 基础知识</a></li>
</ul>
</li>
</ul>
<h2 id="3-智能合约开发"><a href="#3-智能合约开发" class="headerlink" title="3. 智能合约开发"></a>3. 智能合约开发</h2><p>智能合约是 Web3 应用的核心，学习如何编写和部署智能合约至关重要。</p>
<ul>
<li><p><strong>Solidity 编程语言</strong>：以太坊智能合约的主要编程语言。</p>
<ul>
<li><a href="https://docs.soliditylang.org/zh/v0.8.0/">Solidity 官方文档</a></li>
<li><a href="https://solidity-cn.readthedocs.io/zh/develop/">Solidity 中文文档</a></li>
</ul>
</li>
<li><p><strong>开发工具</strong>：使用 Remix、Truffle 或 Hardhat 等工具进行智能合约开发和测试。</p>
<ul>
<li><a href="https://remix.ethereum.org/">Remix 在线 IDE</a></li>
<li><a href="https://www.trufflesuite.com/">Truffle 框架</a></li>
<li><a href="https://hardhat.org/">Hardhat 开发环境</a></li>
</ul>
</li>
</ul>
<h2 id="4-前端与区块链交互"><a href="#4-前端与区块链交互" class="headerlink" title="4. 前端与区块链交互"></a>4. 前端与区块链交互</h2><p>学习如何在前端应用中与区块链进行交互。</p>
<ul>
<li><p><strong>Web3.js 与 Ethers.js</strong>：JavaScript 库，用于与以太坊区块链交互。</p>
<ul>
<li><a href="https://web3js.readthedocs.io/en/v1.3.4/">Web3.js 文档</a></li>
<li><a href="https://docs.ethers.io/v5/">Ethers.js 文档</a></li>
</ul>
</li>
<li><p><strong>钱包集成</strong>：学习如何在应用中集成钱包，如 MetaMask。</p>
<ul>
<li><a href="https://metamask.io/">MetaMask 官方网站</a></li>
</ul>
</li>
<li><p><strong>RainbowKit</strong>：用于在 React 应用中轻松集成钱包连接功能的工具。</p>
<ul>
<li><a href="https://www.rainbowkit.com/docs/introduction">RainbowKit 文档</a></li>
</ul>
</li>
</ul>
<h2 id="5-去中心化存储与身份认证"><a href="#5-去中心化存储与身份认证" class="headerlink" title="5. 去中心化存储与身份认证"></a>5. 去中心化存储与身份认证</h2><p>了解去中心化存储和身份认证在 Web3 应用中的应用。</p>
<ul>
<li><p><strong>IPFS</strong>：分布式存储协议，用于存储和共享文件。</p>
<ul>
<li><a href="https://docs.ipfs.io/">IPFS 官方文档</a></li>
</ul>
</li>
<li><p><strong>去中心化身份认证（DID）</strong>：学习去中心化身份的概念和实现。</p>
<ul>
<li><a href="https://www.w3.org/TR/did-core/">DID 文档</a></li>
</ul>
</li>
</ul>
<h2 id="6-常用开发工具"><a href="#6-常用开发工具" class="headerlink" title="6. 常用开发工具"></a>6. 常用开发工具</h2><p>以下是一些常用的开发工具，帮助提高开发效率。</p>
<ul>
<li><p><strong>Remix</strong>：在线智能合约开发环境。</p>
<ul>
<li><a href="https://remix.ethereum.org/">Remix 在线 IDE</a></li>
</ul>
</li>
<li><p><strong>Truffle</strong>：以太坊开发框架，提供智能合约的编译、部署和测试功能。</p>
<ul>
<li><a href="https://www.trufflesuite.com/">Truffle 框架</a></li>
</ul>
</li>
<li><p><strong>Hardhat</strong>：以太坊开发环境，支持插件扩展，方便调试和测试。</p>
<ul>
<li><a href="https://hardhat.org/">Hardhat 开发环境</a></li>
</ul>
</li>
<li><p><strong>MetaMask</strong>：浏览器插件钱包，方便与以太坊区块链交互。</p>
<ul>
<li><a href="https://metamask.io/">MetaMask 官方网站</a></li>
</ul>
</li>
<li><p><strong>RainbowKit</strong>：React 组件库，简化钱包连接功能的实现。</p>
<ul>
<li><a href="https://www.rainbowkit.com/docs/introduction">RainbowKit 文档</a></li>
</ul>
</li>
</ul>
<h2 id="7-推荐视频资源"><a href="#7-推荐视频资源" class="headerlink" title="7. 推荐视频资源"></a>7. 推荐视频资源</h2><p>以下是一些在 Bilibili 和 YouTube 上点赞评论较高、发布时间较新的 Web3 相关视频，供您参考学习。</p>
<ul>
<li><p><strong>Bilibili</strong>：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Gk4y147Ex/">Web3 学习路线图</a></li>
<li><a href="https://www.bilibili.com/video/BV14A411178x/?spm_id_from=333.337.search-card.all.click&vd_source=1705f0c588139215ea65124e687fa306">千锋教育前端Web3.0 DeFi项目实战教程</a></li>
<li><a href="https://www.bilibili.com/video/BV1TxNtetEaj/?spm_id_from=333.337.search-card.all.click&vd_source=1705f0c588139215ea65124e687fa306">Web3 前端训练营上</a></li>
<li><a href="https://www.bilibili.com/video/BV1kFBQYEECF/?spm_id_from=333.337.search-card.all.click&vd_source=1705f0c588139215ea65124e687fa306">Web3 前端训练营下</a></li>
<li><a href="https://www.bilibili.com/video/BV1pM4m1S74X/?spm_id_from=333.337.search-card.all.click&vd_source=1705f0c588139215ea65124e687fa306">Web3 前端框架和合约关系</a></li>
</ul>
</li>
<li><p><strong>YouTube</strong>：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=H82UBvRtkuc">Web3 Dapp 开发学习路线图 | 14 | Web3 前端基础库</a></li>
<li><a href="https://www.youtube.com/watch?v=kavKpgYKzeg">Web3 Dapp 开发学习路线图 | 15 | Web3 前端交互库</a></li>
<li><a href="https://www.youtube.com/watch?v=6alsggA957I">Web3.0 从入门到精通学习路线图</a></li>
</ul>
</li>
</ul>
<p>通过以上学习路线的逐步深入，您将从前端开发的基础知识开始，逐步掌握 Web3 应用开发的核心技能，最终能够独立开发复杂的去中心化应用。祝您的学习之旅顺利！</p>
]]></content>
      <tags>
        <tag>Web3</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义View 跳转不同界面方法</title>
    <url>/2016/07/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E7%95%8C%E9%9D%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="自定义View-跳转不同界面方法"><a href="#自定义View-跳转不同界面方法" class="headerlink" title="自定义View 跳转不同界面方法"></a>自定义View 跳转不同界面方法</h2><p>有时候，我们在自定义UIView 的时候 ， 很有可能 会在这个View 进行页面跳转，但是， 你会发现， 那些 push  和  pop 方法  都没什么用  ，那是因为 当一个子view需要接收点击事件，而父view也需要接收点击事件</p>
<p> 当然，你可能会说直接调用mysubview.superView即可，这样做也确实是可以做到，但有时子view是不一定知道有这个特定的父view的存在的，如动态添加子view。</p>
<p> 所以这里就用到了事件处理与传递。</p>
<span id="more"></span>
<h3 id="简单介绍一下"><a href="#简单介绍一下" class="headerlink" title="简单介绍一下"></a>简单介绍一下</h3><ul>
<li>ios当中常用的事件?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 触摸事件</span><br><span class="line">- 加速计事件</span><br><span class="line">- 远程控制事件</span><br></pre></td></tr></table></figure>
<ul>
<li>什么是响应者对象?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">继承了UIResponds的对象我们称它为响应者对象</span><br><span class="line">UIApplication、UIViewController、UIView都继承自UIResponder</span><br><span class="line">因此它们都是响应者对象，都能够接收并处理事件</span><br></pre></td></tr></table></figure>
<ul>
<li>事件是怎么样产生与传递的?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中.</span><br><span class="line">UIApplication会从事件队列中取出最前面的事件，交给主窗口.</span><br><span class="line">主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件</span><br><span class="line">触摸事件的传递是从父控件传递到子控件的.</span><br><span class="line">如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件.</span><br></pre></td></tr></table></figure>
<ul>
<li>一个控件什么情况下不能够接收事件?</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 不接收用户交互时不能够处理事件</span><br><span class="line">         </span><br><span class="line">         userInteractionEnabled = NO</span><br><span class="line">- 当一个控件隐藏的时候不能够接收事件</span><br><span class="line">         </span><br><span class="line">         Hidden = YES的时候</span><br><span class="line">- 当一个控件为透明白时候也不能够接收事件</span><br><span class="line">         </span><br><span class="line">         alpha &lt;=0.01</span><br></pre></td></tr></table></figure>
<h5 id="注意-UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的"><a href="#注意-UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的" class="headerlink" title="注意:UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的"></a>注意:UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的</h5><ul>
<li>如何寻找最合适的View?</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 先判断自己是否能够接收触摸事件,如果能再继续往下判断,</span><br><span class="line">- 再判断触摸的当前点在不在自己的身上.</span><br><span class="line">- 如果在自己身上,UIWindow会从后往前（后创建的子控件开始）遍历子控件,遍历出每一个子控件后,重复前面的两个步骤.</span><br><span class="line">- 如果没有符合条件的子控件,那么它自己就是最适合的View.</span><br></pre></td></tr></table></figure>
<p>回到主题上来，下面要做的也就是，让子view接收这些事件后，同时把这些事件继续向上传，会一直传到UIApplication为止。而在传的过程中，如果子view接收了这些事件，那么事件会自然终止，我们现在可以做的是同时让子view接收事件，而且还让事件不终止，并继续向上传。</p>
<p>步骤应该是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个全局变量    </span></span><br><span class="line"><span class="built_in">UIViewController</span> *superVC;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后执行这个方法</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)viewController:(<span class="built_in">UIView</span> *)view&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIResponder</span> *responder = view;</span><br><span class="line">    <span class="keyword">while</span> ((responder = [responder nextResponder]))</span><br><span class="line">    <span class="keyword">if</span> ([responder isKindOfClass: [<span class="built_in">UIViewController</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后，在你跳转页面的方法中</span></span><br><span class="line">superVC = [<span class="keyword">self</span> viewController:<span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line">[superVC.navigationController pushViewController:（<span class="built_in">UIViewController</span>） animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>这样就可以跳转页面了.</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义图片下载</title>
    <url>/2019/06/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>学习完SDWebImage第三方框架之后，根据它的流程，试着简写自定义下载图片的方法。</p>
<span id="more"></span>
<h4 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - 单例</span><br><span class="line">static CHImageManager *_sharedInstance;</span><br><span class="line">+ (CHImageManager *)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        if (!_sharedInstance) &#123;</span><br><span class="line">            _sharedInstance = [[CHImageManager alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return _sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedInstance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置URL缓存过滤器并给出方法"><a href="#设置URL缓存过滤器并给出方法" class="headerlink" title="设置URL缓存过滤器并给出方法"></a>设置URL缓存过滤器并给出方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义缓存过滤器的block块</span><br><span class="line">typedef NSString *(^CHImageCacheKeyFilterBlock)(NSURL *url);</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) CHImageCacheKeyFilterBlock cacheKeyFilter; //缓存过滤器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - URL过滤器</span><br><span class="line">//返回指定URL的缓存键值，就是URL字符串</span><br><span class="line">- (NSString *)cacheKeyForURL:(NSURL *)url &#123;</span><br><span class="line">    //如果URL不存在，那么就返回空</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //先判断是否设置了缓存过滤器，如果设置了则走cacheKeyFilterBlock,否则直接把URL转换为字符串之后返回</span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [url absoluteString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要外部自己设置过滤规则 实现cacheKeyFilter相关</p>
<h4 id="自定义下载方法"><a href="#自定义下载方法" class="headerlink" title="自定义下载方法"></a>自定义下载方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)customImageView:(UIImageView *)imageView UrlStr:(NSURL *)urlStr&#123;</span><br><span class="line"></span><br><span class="line">    //容错处理</span><br><span class="line">    if ([urlStr isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        urlStr = [NSURL URLWithString:(NSString *)urlStr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (![urlStr isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        urlStr = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!urlStr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 缓存key</span><br><span class="line">    NSString *cacheKey = [self cacheKeyForURL:urlStr];</span><br><span class="line"></span><br><span class="line">/* 从内存缓存中取 */</span><br><span class="line">    UIImage *image = [self.imagesCache objectForKey:cacheKey];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        // 直接设置</span><br><span class="line">        imageView.image = image;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">/* 检查磁盘缓存 */</span><br><span class="line">        // 获取文件路径</span><br><span class="line">        NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">        // 获取图片名称 获取节点</span><br><span class="line">        NSString *fileName = [cacheKey lastPathComponent];</span><br><span class="line">        // 拼接文件全路径</span><br><span class="line">        NSString *fullPath = [cachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">        // 从磁盘缓存中取</span><br><span class="line">        NSData *data = [NSData dataWithContentsOfFile:fullPath];</span><br><span class="line"></span><br><span class="line">        if (data) &#123;</span><br><span class="line">            // 将二进制数据转成图片</span><br><span class="line">            UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">            // 设置图片</span><br><span class="line">            imageView.image = image;</span><br><span class="line">            // 把图片存到内存缓存中</span><br><span class="line">            [self.imagesCache setObject:image forKey:cacheKey];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">/* 检查操作缓存 */</span><br><span class="line">            // 清空图片或者占位图片</span><br><span class="line">            imageView.image = nil;</span><br><span class="line">            // 检查操作缓存</span><br><span class="line">            NSBlockOperation *downloadOperation = [self.operationsCache objectForKey:cacheKey];</span><br><span class="line">            if (downloadOperation) &#123;</span><br><span class="line">                // 不处理</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                downloadOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">                    // 下载图片三部曲</span><br><span class="line">                    NSData *tempData = [NSData dataWithContentsOfURL:urlStr];</span><br><span class="line">                    UIImage *tempImage = [UIImage imageWithData:tempData];</span><br><span class="line">                    if (tempImage == nil) &#123;</span><br><span class="line">                        // 移除操作缓存中的操作</span><br><span class="line">                        [self.operationsCache removeObjectForKey:cacheKey];</span><br><span class="line">                        return ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 把图片存到内存缓存</span><br><span class="line">                    [self.imagesCache setObject:tempImage forKey:cacheKey];</span><br><span class="line"></span><br><span class="line">                    // 把图片保存到磁盘缓存</span><br><span class="line">                    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">                        [data writeToFile:fullPath atomically:YES];</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    // 回到主线程</span><br><span class="line">                    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                        // 设置图片</span><br><span class="line">                      //imageView.image = tempImage;</span><br><span class="line">                        // 刷新一行(会重新调用cellForRow方法)</span><br><span class="line">                      //[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight];</span><br><span class="line"></span><br><span class="line">                    &#125;];</span><br><span class="line">                &#125;];</span><br><span class="line">                // 添加操作缓存</span><br><span class="line">                [self.operationsCache setObject:downloadOperation forKey:cacheKey];</span><br><span class="line">                // 将操作加入队列</span><br><span class="line">                [self.queue addOperation:downloadOperation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除缓存策略"><a href="#移除缓存策略" class="headerlink" title="移除缓存策略"></a>移除缓存策略</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - 清除缓存</span><br><span class="line">- (void)cleanCache&#123;</span><br><span class="line">    // 内存缓存</span><br><span class="line">    [self.imagesCache removeAllObjects];</span><br><span class="line">    // 操作缓存</span><br><span class="line">    [self.operationsCache removeAllObjects];</span><br><span class="line">    // 取消队列中的操作</span><br><span class="line">    [self.queue cancelAllOperations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是具体实现方法 <a href="/download/CHImageManager.zip">点击查看</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
